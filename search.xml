<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FCC Object Oriented and Functional Programming]]></title>
    <url>%2F2019%2F06%2F17%2FFCC-Object-Oriented-and-Functional-Programming%2F</url>
    <content type="text"><![CDATA[Declare JavaScript Objects as Variables Incomplete在我们深入 面向对象编程之前 ，让我们先回顾一下Javascript的 对象（Object） 任务给你的 motorBike 对象添加 wheels, engines 和 seats 属性，并且设置他们的数量。 1234567891011var car = &#123; "wheels":4, "engines":1, "seats":5&#125;;var motorBike = &#123; "engines":1, "wheels":2, "seats":1&#125;; Construct JavaScript Objects with Functions Incomplete除了上一种方法外，我们还可以使用构造函数来创建对象。 构造函数 通常使用大写字母开头，以便把自己和其他普通函数区别开。 下面便是一个 构造函数 了： 12345var Car = function() &#123; this.wheels = 4; this.engines = 1; this.seats = 1;&#125;; 在 构造函数 中， this 指向被此 构造函数 创建出来的 对象 。所以，当我们在 构造函数 中写： 1this.wheels = 4; 这时，它创建出来的新对象将带有 wheels 属性，并且赋值为 4. 你可以认为 构造函数 描述了它所创建出来的对象。 任务让你的 MotorBike 构造函数 描述一个具有 wheels, engines 和 seats 属性的 对象 ，并且为这些属性设置值。 1234567891011var Car = function() &#123; this.wheels = 4; this.engines = 1; this.seats = 1;&#125;;var MotorBike = function() &#123; this.wheels = 2; this.engines = 1; this.seats = 1;&#125;; Make Instances of Objects with a Constructor Function Incomplete现在，我们把上一节课我们写的 构造函数 在这里用起来！ 使用构造函数时，我们通过在它前面使用 new 关键字 来对它进行调用，如下： 1var myCar = new Car(); myCar 现在成为了 Car 的一个 实例（instance），它被 构造函数 描述成下面的样子： 12345&#123; wheels: 4, engines: 1, seats: 1&#125; 记住：要使用 new 关键字 去调用构造函数。因为只有这样，Javascript才知道这是要去构造一个新 对象 ，并且把构造函数中的 this 指向这个新对象。 现在，当 myCar （即 Car 的一个 实例 ）创建后，他可以像普通对象一样被使用，包括创建、访问、修改它的属性等，就像我们使用其他对象一样。如下： 1myCar.turboType = &quot;twin&quot;; 我们的 myCar 变量现在有了一个 turboType 属性了，且值为 &quot;twin&quot; 。 在编辑器中，使用 Car 这个构造函数去创建一个新的 实例 ，并且把这个实例赋值给 myCar 。 然后给 myCar 创建一个 nickname 属性，且属性值为一个字符串 任务123456789var Car = function() &#123; this.wheels = 4; this.engines = 1; this.seats = 1;&#125;;var myCar = new Car();myCar.nickname = 'zzz'; Make Unique Objects by Passing Parameters to our Constructor Incomplete我们之前写的 构造函数 很好，但是我们不想总是创建相同的对象，怎么办呢？ 为了解决这个问题，我们要向 构造函数 中添加 参数 。像下面这样： 12345var Car = function(wheels, seats, engines) &#123; this.wheels = wheels; this.seats = seats; this.engines = engines;&#125;; 现在，我们可以在调用 构造函数 时传入一组 参数 了。 1var myCar = new Car(6, 3, 1); 这段代码将会使用这一组 参数 来创建出下面的对象： 12345&#123; wheels: 6, seats: 3, engines: 1&#125; 现在该你试试了！改动 Car 的 构造函数 ，使它能够通过使用 参数 来为 wheels 、 seats 、 engines 属性进行赋值。 然后调用你刚刚改写过的 构造函数 ，并传入三个 参数 ，我们就能看到创建的新对象赋值给了 myCar 。 任务1234567var Car = function(wheels, seats, engines) &#123; this.wheels = wheels; this.seats = seats; this.engines = engines;&#125;;var myCar = new Car(2,6,3); Make Object Properties Private Incomplete对象拥有自己的特征，称为 属性，对象还有自己的函数，称为 方法 。 在前面的课程（构造函数）中，我们使用了 this 指向当前（将要被创建的）对象中的 公有属性 。 我们也可以创建 私有属性 和 私有方法 ，它们两个在对象外部是不可访问的。 为了完成这个任务，我们在 构造函数 中，使用我们熟悉的 var 关键字去创建变量，来替代我们使用 this 创建 属性 。 比如，我们想记录我们的car行驶的 speed ，但是我们希望外面的代码对 speed 的修改只能是加速或减速（而不是变成字符串、直接赋值成某个速度等其他操作），那么如何达到这类操作的目的呢？ 编辑器中的 构造函数 展示了如何实现这种控制模式。 该你自己试试了！修改 Bike 的 构造函数 ，使它有一个名为 gear 的 私有属性 ，还有两个公有方法，叫做 getGear 和 setGear ，这两个方法用来获得和设置 gear 的值。 任务1234567891011121314151617181920212223242526272829303132333435var Car = function() &#123; // this is a private variable var speed = 10; // these are public methods this.accelerate = function(change) &#123; speed += change; &#125;; this.decelerate = function() &#123; speed -= 5; &#125;; this.getSpeed = function() &#123; return speed; &#125;;&#125;;var Bike = function() &#123; // Only change code below this line. var gear=0; this.getGear = function()&#123; return gear; &#125;; this.setGear = function(set)&#123; gear = set; &#125;; &#125;;var myCar = new Car();var myBike = new Bike(); Iterate over Arrays with .map Incompletemap 方法可以方便的迭代数组，例子： 123var timesFour = oldArray.map(function(val)&#123; return val * 4;&#125;); map 方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。注意，这个方法不会改变原始数组。 在我们的例子中，回调函数只有一个参数，即数组中元素的值 (val 参数) ，但其实，你的回调函数也可以支持多个参数，譬如：元素的索引index、原始数组arr。 使用 map 方法来为 oldArray 中的每一项增加3，并且在 newArray 中保存它们。 oldArray 不应该被改变。 任务12345var array = [1,2,3,4,5];var newArray = oldArray.map(function(val) &#123; return val + 3;&#125;); Condense arrays with .reduce Incomplete数组方法 reduce 用来迭代一个数组，并且把它累积到一个值中。 使用 reduce 方法时，你要传入一个回调函数，这个回调函数的参数是一个 累加器 （比如例子中的 previousVal) 和当前值 (currentVal）。 reduce 方法有一个可选的第二参数，它可以被用来设置累加器的初始值。如果没有在这定义初始值，那么初始值将变成数组中的第一项，而 currentVal 将从数组的第二项开始。 下面的例子使用了 reduce 来让数组中的所有值相减： 123var singleVal = array.reduce(function(previousVal, currentVal) &#123; return previousVal - currentVal;&#125;, 0); 使用 reduce 方法来让 array 中的所有值相加，并且把结果赋值给 singleVal 。 任务123456var array = [4,5,6,7,8];var singleVal = 0;singleVal = array.reduce(function(prev, curr) &#123; return prev + curr;&#125;); Filter Arrays with .filter Incompletefilter 方法用来迭代一个数组，并且按给出的条件过滤出符合的元素。 filter 方法传入一个回调函数，这个回调函数会携带一个参数，参数为当前迭代的项（我们叫它 val ）。 回调函数返回 true 的项会保留在数组中，返回 false的项会被过滤出数组。 下面的代码示例展示了使用 filter 来移除数组中值等于5的项： 注意： 我们忽略了第二参数和第三参数，因为例子中我们只需要第一参数就够了。 123array = array.filter(function(val) &#123; return val !== 5;&#125;); 使用 filter 来创建一个新数组，新数组的值是 oldArray 中值小于6的元素。不许改变原数组 oldArray 。 任务12345var oldArray = [1,2,3,4,5,6,7,8,9,10];var newArray = oldArray.filter(function(val) &#123; return val &lt; 6;&#125;); Sort Arrays with .sort Incomplete使用 sort 方法，你可以很容易的按字母顺序或数字顺序对数组中的元素进行排序。 与我们之前用的数组方法仅仅返回一个新数组不同， sort 方法将改变原数组，返回被排序后的数组。 sort 可以把比较函数作为参数传入。比较函数有返回值，当 a 小于 b，返回一个负数；当 a 大于 b ，返回一个正数；相等时返回0。 如果没有传入比较函数，它将把值全部转成字符串，并按照字母顺序进行排序。 下面的例子将展示 sort 的使用，传入的比较函数把元素按照从小到大的顺序进行排列： 1234var array = [1, 12, 21, 2];array.sort(function(a, b) &#123; return a - b;&#125;); 使用 sort 按照从大到小的顺序排序 array 。 任务12345var array = [1, 12, 21, 2];array.sort(function(a, b) &#123; return b - a;&#125;); Reverse Arrays with .reverse Incomplete你可以使用 reverse 方法来翻转数组。 12var myArray = [1, 2, 3];myArray.reverse(); 结果myArray 变成了 [3, 2, 1] 使用 reverse 来翻转 array 数组。并赋值给 newArray. 任务1234var array = [1,2,3,4,5,6,7];var newArray = [];newArray = array.reverse(); Concatenate Arrays with .concat Incompleteconcat 方法可以用来把两个数组的内容合并到一个数组中。 concat 方法的参数应该是一个数组。参数中的数组会拼接在原数组的后面，并作为一个新数组返回。 下面是一个拼接数组的例子，用concat 把 otherArray拼接在 oldArray 的后面： 1newArray = oldArray.concat(otherArray); 使用 .concat() 将 concatMe 拼接到 oldArray 后面，并且赋值给 newArray。 任务123456var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe); Split Strings with .split Incomplete你可以使用 split 方法按指定分隔符将字符串分割为数组。 你要给 split 方法传递一个参数，这个参数将会作为一个分隔符。 下面的例子展示了 split 方法的使用，按照 s 字母进行分割： 1var array = string.split(&apos;s&apos;); 使用 split 方法来把字符串 string 分割为数组 array。 任务1234var string = "Split me into an array";var array = [];array = string.split(" "); Join Strings with .join我们还可以使用 join 方法来把数组转换成字符串，里面的每一个元素可以用你指定的连接符来连接起来，这个连接符就是你要传入的参数。 下面展示了使用 join 来将数组中的每一项放入字符串，并用 and进行连接： 123var veggies = ["Celery", "Radish", "Carrot", "Potato"];var salad = veggies.join(" and ");console.log(salad); // "Celery and Radish and Carrot and Potato" 使用 join 方法，连接符为&#39; &#39;把数组 joinMe 转化成字符串 joinedString. 任务1234var joinMe = ["Split","me","into","an","array"];var joinedString = '';joinedString = joinMe.join(" ");]]></content>
  </entry>
  <entry>
    <title><![CDATA[FCC ES6]]></title>
    <url>%2F2019%2F06%2F14%2FFCC-ES6%2F</url>
    <content type="text"><![CDATA[var 和 let 的区别One of the biggest problems with declaring variables with the varkeyword is that you can overwrite variable declarations without an error. 用var关键词去声明变量，是可以被覆盖的。 1234var camper = 'James';var camper = 'David';console.log(camper);// logs 'David' As you can see in the code above, the campervariable is originally declared as Jamesand then overridden to be David. 例如上面，原本变量camper是James，之后被David覆盖了。 In a small application, you might not run into this type of problem, but when your code becomes larger, you might accidentally overwrite a variable that you did not intend to overwrite. 在小的程序里，你可能不会遇到这种问题，但一旦你的代码多了起来，就可能覆盖了你原本没打算覆盖的变量。 Because this behavior does not throw an error, searching and fixing bugs becomes more difficult. 因为这不会造成异常，后期搜索及修复bugs的时候会变得很困难。 A new keyword called letwas introduced in ES6 to solve this potential issue with the varkeyword. ES6里的关键词let可以解决这种问题。 If you were to replace varwith letin the variable declarations of the code above, the result would be an error. 如果你用let去替换var，那结果是异常的。 12let camper = 'James';let camper = 'David'; // throws an error This error can be seen in the console of your browser. 你在浏览器的控制台可以看到错误。 So unlike var, when using let, a variable with the same name can only be declared once. 当你使用let的时候，注意，相同名称的变量只能声明一次。 Note the &quot;use strict&quot;. This enables Strict Mode, which catches common coding mistakes and “unsafe” actions. For instance: 请注意&quot;use strict&quot;。这启用了严格模式，可以捕获常见的编码错误和“不安全”操作。 12"use strict";x = 3.14; // throws an error because x is not declared 练习12345678910let catName;let quote;function catTalk() &#123; "use strict"; catName = "Oliver"; quote = catName + " says Meow!";&#125;catTalk(); 对比 var 和 let 的作用域When you declare a variable with the varkeyword, it is declared globally, or locally if declared inside a function. 当你用var声明变量时，声明是全局作用域或者在函数里的局部作用域。 The letkeyword behaves similarly, but with some extra features. When you declare a variable with the letkeyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression. 关键词let也差不多，当你在block/statement/expression里用let声明变量，它的作用域就被限制在里面。 For example: 12345678var numArray = [];for (var i = 0; i &lt; 3; i++) &#123; numArray.push(i);&#125;console.log(numArray);// returns [0, 1, 2]console.log(i);// returns 3 With the varkeyword, iis declared globally. So when i++is executed, it updates the global variable. This code is similar to the following: 用var关键词，i是全局作用域，当执行到i++时，会更新全局变量。 123456789var numArray = [];var i;for (i = 0; i &lt; 3; i++) &#123; numArray.push(i);&#125;console.log(numArray);// returns [0, 1, 2]console.log(i);// returns 3 This behavior will cause problems if you were to create a function and store it for later use inside a for loop that uses the ivariable. This is because the stored function will always refer to the value of the updated global ivariable. 如果你要创建一个函数并将其存储以供以后在使用该i变量的for循环中使用，则此行为将导致问题。这是因为存储的函数将始终引用更新的全局i变量的值。 12345678910var printNumTwo;for (var i = 0; i &lt; 3; i++) &#123; if(i === 2)&#123; printNumTwo = function() &#123; return i; &#125;; &#125;&#125;console.log(printNumTwo());// returns 3 As you can see, printNumTwo()prints 3 and not 2. This is because the value assigned to iwas updated and the printNumTwo()returns the global iand not the value ihad when the function was created in the for loop. The letkeyword does not follow this behavior: 正如你所看到的，printNumTwo()打印3而不是2.这是因为分配给的值i已更新，并且printNumTwo()返回全局i而不是i在for循环中创建函数时的值。该let关键字不遵循这种行为： 12345678910111213'use strict';let printNumTwo;for (let i = 0; i &lt; 3; i++) &#123; if (i === 2) &#123; printNumTwo = function() &#123; return i; &#125;; &#125;&#125;console.log(printNumTwo());// returns 2console.log(i);// returns "i is not defined" iis not defined because it was not declared in the global scope. It is only declared within the for loop statement. printNumTwo()returned the correct value because three different ivariables with unique values (0, 1, and 2) were created by the letkeyword within the loop statement. i未定义，因为它未在全局范围内声明。它仅在for循环语句中声明。printNumTwo()返回正确的值，因为循环语句中i的let关键字创建了具有唯一值（0,1和2）的三个不同变量。 练习1234567891011function checkScope() &#123; 'use strict'; let i = 'function scope'; if (true) &#123; let i = 'block scope'; console.log('Block scope i is: ', i); &#125; console.log('Function scope i is: ', i); return i;&#125; Declare a Read-Only Variable with the const Keywordletis not the only new way to declare variables. In ES6, you can also declare variables using the constkeyword. consthas all the awesome features that lethas, with the added bonus that variables declared using constare read-only. They are a constant value, which means that once a variable is assigned with const, it cannot be reassigned. let并不是唯一声明变量的新方法。在ES6中，还可以使用const关键字声明变量。 const的好处是声明使用的变量是只读的。它们是一个常量值，这意味着一旦赋值变量const，就不能重新赋值。 123"use strict"const FAV_PET = "Cats";FAV_PET = "Dogs"; // returns error As you can see, trying to reassign a variable declared with constwill throw an error. You should always name variables you don’t want to reassign using the constkeyword. This helps when you accidentally attempt to reassign a variable that is meant to stay constant. A common practice when naming constants is to use all uppercase letters, with words separated by an underscore. 如你所见，尝试重新分配声明的变量const将引发错误。你应该始终使用const关键字命名您不想重新分配的变量。当你意外尝试重新分配一个旨在保持不变的变量时，这会有所帮助。 命名常量时的常见做法是使用全部大写字母，单词用下划线分隔。 练习1234567891011121314function printManyTimes(str) &#123; "use strict"; // change code below this line const SENTENCE = str + " is cool!"; for(let i = 0; i &lt; str.length; i+=2) &#123; console.log(SENTENCE); &#125; // change code above this line&#125;printManyTimes("freeCodeCamp"); Mutate an Array Declared with constThe constdeclaration has many use cases in modern JavaScript. Some developers prefer to assign all their variables using constby default, unless they know they will need to reassign the value. Only in that case, they use let. However, it is important to understand that objects (including arrays and functions) assigned to a variable using constare still mutable. Using the constdeclaration only prevents reassignment of the variable identifier. const声明在现代JavaScript中有许多用例。 一些开发人员更喜欢const默认使用所有变量，除非他们知道需要重新分配值。只有在这种情况下，他们才会使用let。 但是，重要的是要理解分配给变量的对象（包括数组和函数）const仍然是可变的。使用const声明仅阻止重新分配变量标识符。 12345"use strict";const s = [5, 6, 7];s = [1, 2, 3]; // throws error, trying to assign a consts[2] = 45; // works just as it would with an array declared with var or letconsole.log(s); // returns [5, 6, 45] As you can see, you can mutate the object [5, 6, 7]itself and the variable swill still point to the altered array [5, 6, 45]. Like all arrays, the array elements in sare mutable, but because constwas used, you cannot use the variable identifier sto point to a different array using the assignment operator. 如你所见，你可以改变对象[5, 6, 7]本身，变量s仍将指向更改的数组[5, 6, 45]。 与所有数组一样，数组元素s是可变的，但由于const被使用了，你不能使用变量标识符s指向使用赋值运算符的不同的数组。 练习123456789101112const s = [5, 7, 2];function editInPlace() &#123; 'use strict'; // change code below this line // s = [2, 5, 7]; &lt;- this is invalid s[0] = 2; s[1] = 5; s[2] = 7; // change code above this line&#125;editInPlace(); Prevent Object MutationAs seen in the previous challenge, constdeclaration alone doesn’t really protect your data from mutation. To ensure your data doesn’t change, JavaScript provides a function Object.freezeto prevent data mutation. Once the object is frozen, you can no longer add, update, or delete properties from it. Any attempt at changing the object will be rejected without an error. 正如之前的挑战所示，const仅凭声明并不能真正保护您的数据免受突变。为确保您的数据不会发生变化，JavaScript提供了Object.freeze防止数据突变的功能。 对象冻结后，您将无法再从中添加，更新或删除属性。任何更改对象的尝试都将被拒绝而不会出现错误。 123456789let obj = &#123; name:"FreeCodeCamp", review:"Awesome"&#125;;Object.freeze(obj);obj.review = "bad"; //will be ignored. Mutation not allowedobj.newProp = "Test"; // will be ignored. Mutation not allowedconsole.log(obj); // &#123; name: "FreeCodeCamp", review:"Awesome"&#125; 练习1234567891011121314151617function freezeObj() &#123; 'use strict'; const MATH_CONSTANTS = &#123; PI: 3.14 &#125;; // change code below this line Object.freeze(MATH_CONSTANTS); // change code above this line try &#123; MATH_CONSTANTS.PI = 99; &#125; catch(ex) &#123; console.log(ex); &#125; return MATH_CONSTANTS.PI;&#125;const PI = freezeObj(); Use Arrow Functions to Write Concise Anonymous FunctionsIn JavaScript, we often don’t need to name our functions, especially when passing a function as an argument to another function. Instead, we create inline functions. We don’t need to name these functions because we do not reuse them anywhere else. 在JavaScript中，我们通常不需要命名我们的函数，特别是在将函数作为参数传递给另一个函数时。相反，我们创建内联函数。我们不需要命名这些函数，因为我们不会在其他任何地方重用它们。 To achieve this, we often use the following syntax: 为此，我们经常使用以下语法： 1234const myFunc = function() &#123; const myVar = "value"; return myVar;&#125; ES6 provides us with the syntactic sugar to not have to write anonymous functions this way. Instead, you can use arrow function syntax: ES6为我们提供了语法糖，而不必以这种方式编写匿名函数。相反，你可以使用箭头函数语法： 1234const myFunc = () =&gt; &#123; const myVar = "value"; return myVar;&#125; When there is no function body, and only a return value, arrow function syntax allows you to omit the keyword returnas well as the brackets surrounding the code. This helps simplify smaller functions into one-line statements: 当没有函数体，并且只有返回值时，箭头函数语法允许你省略关键字return以及代码周围的括号。这有助于将较小的函数简化为单行语句： 1const myFunc = () =&gt; "value" This code will still return valueby default. 练习1234const magic = () =&gt; &#123; "use strict"; return new Date();&#125;; Write Arrow Functions with ParametersJust like a normal function, you can pass arguments into arrow functions. 就像普通函数一样，您可以将参数传递给箭头函数。 12// doubles input value and returns itconst doubler = (item) =&gt; item * 2; You can pass more than one argument into arrow functions as well. 你也可以将多个参数传递给箭头函数。 练习123456const myConcat = (arr1, arr2) =&gt; &#123; "use strict"; return arr1.concat(arr2);&#125;;// test your codeconsole.log(myConcat([1, 2], [3, 4, 5])); Write Higher Order Arrow FunctionsIt’s time we see how powerful arrow functions are when processing data. Arrow functions work really well with higher order functions, such as map(), filter(), and reduce(), that take other functions as arguments for processing collections of data. Read the following code: 是时候我们看到处理数据时箭头函数有多强大了。 箭头函数和其他高阶函数搭配一起时运作得很好，比如map()，filter()和reduce()，是把其他的函数作为数据的处理收集论据。 阅读以下代码： 123FBPosts.filter(function(post) &#123; return post.thumbnail !== null &amp;&amp; post.shares &gt; 100 &amp;&amp; post.likes &gt; 500;&#125;) We have written this with filter()to at least make it somewhat readable. Now compare it to the following code which uses arrow function syntax instead: 我们写这篇文章filter()至少使它有点可读。现在将它与以下使用箭头函数语法的代码进行比较： 1FBPosts.filter((post) =&gt; post.thumbnail !== null &amp;&amp; post.shares &gt; 100 &amp;&amp; post.likes &gt; 500) This code is more succinct and accomplishes the same task with fewer lines of code. 此代码更简洁，使用更少的代码行完成相同的任务。 练习12345678910111213141516const realNumberArray = [4, 5.6, -9.8, 3.14, 42, 6, 8.34];const squareList = (arr) =&gt; &#123; "use strict"; // change code below this line const squaredIntegers = []; arr.map( num =&gt; &#123; if(Number.isInteger(num))&#123; squaredIntegers.push(num * num); &#125; &#125;) // change code above this line return squaredIntegers;&#125;;// test your codeconst squaredIntegers = squareList(realNumberArray);console.log(squaredIntegers); Set Default Parameters for Your FunctionsIn order to help us create more flexible functions, ES6 introduces default parameters for functions. Check out this code: 12345function greeting(name = "Anonymous") &#123; return "Hello " + name;&#125;console.log(greeting("John")); // Hello Johnconsole.log(greeting()); // Hello Anonymous The default parameter kicks in when the argument is not specified (it is undefined). As you can see in the example above, the parameter namewill receive its default value &quot;Anonymous&quot;when you do not provide a value for the parameter. You can add default values for as many parameters as you want. 练习1234const increment = (number, value = 1) =&gt; number + value;console.log(increment(5, 2)); // returns 7console.log(increment(5)); // returns 6 Use the Rest Operator with Function ParametersIn order to help us create more flexible functions, ES6 introduces the rest operator for function parameters. With the rest operator, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function. Check out this code: 12345function howMany(...args) &#123; return "You have passed " + args.length + " arguments.";&#125;console.log(howMany(0, 1, 2)); // You have passed 3 argumentsconsole.log(howMany("string", null, [1, 2, 3], &#123; &#125;)); // You have passed 4 arguments. The rest operator eliminates the need to check the argsarray and allows us to apply map(), filter()and reduce()on the parameters array. 练习12345'use strict';function sum(...args) &#123; return args.reduce((a, b) =&gt; a + b, 0);&#125;console.log(sum(1, 2, 3)); // 6 Use the Spread Operator to Evaluate Arrays In-PlaceES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected. The ES5 code below uses apply()to compute the maximum value in an array: 12var arr = [6, 89, 3, 45];var maximus = Math.max.apply(null, arr); // returns 89 We had to use Math.max.apply(null, arr)because Math.max(arr)returns NaN. Math.max()expects comma-separated arguments, but not an array. The spread operator makes this syntax much better to read and maintain. 12const arr = [6, 89, 3, 45];const maximus = Math.max(...arr); // returns 89 ...arrreturns an unpacked array. In other words, it spreads the array. However, the spread operator only works in-place, like in an argument to a function or in an array literal. The following code will not work: 1const spreaded = ...arr; // will throw a syntax error 练习1234const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];let arr2;arr2 = [...arr1]; Use Destructuring Assignment to Assign Variables from ObjectsWe saw earlier how spread operator can effectively spread, or unpack, the contents of the array. We can do something similar with objects as well. Destructuring assignment is special syntax for neatly assigning values taken directly from an object to variables. Consider the following ES5 code: 1234var voxel = &#123;x: 3.6, y: 7.4, z: 6.54 &#125;;var x = voxel.x; // x = 3.6var y = voxel.y; // y = 7.4var z = voxel.z; // z = 6.54 Here’s the same assignment statement with ES6 destructuring syntax: 1const &#123; x, y, z &#125; = voxel; // x = 3.6, y = 7.4, z = 6.54 If instead you want to store the values of voxel.xinto a, voxel.yinto b, and voxel.zinto c, you have that freedom as well. 1const &#123; x : a, y : b, z : c &#125; = voxel // a = 3.6, b = 7.4, c = 6.54 You may read it as “get the field xand copy the value into a,” and so on. 练习1234567891011121314const AVG_TEMPERATURES = &#123; today: 77.5, tomorrow: 79&#125;;function getTempOfTmrw(avgTemperatures) &#123; "use strict"; // change code below this line const &#123;tomorrow:tempOfTomorrow&#125; = avgTemperatures; // change this line // change code above this line return tempOfTomorrow;&#125;console.log(getTempOfTmrw(AVG_TEMPERATURES)); // should be 79 Use Destructuring Assignment to Assign Variables from Nested ObjectsWe can similarly destructure nested objects into variables. Consider the following code: 123456const a = &#123; start: &#123; x: 5, y: 6&#125;, end: &#123; x: 6, y: -9 &#125;&#125;;const &#123; start : &#123; x: startX, y: startY &#125;&#125; = a;console.log(startX, startY); // 5, 6 In the example above, the variable startis assigned the value of a.start, which is also an object. 练习1234567891011121314const LOCAL_FORECAST = &#123; today: &#123; min: 72, max: 83 &#125;, tomorrow: &#123; min: 73.3, max: 84.6 &#125;&#125;;function getMaxOfTmrw(forecast) &#123; "use strict"; // change code below this line const &#123;tomorrow:&#123;max:maxOfTomorrow&#125;&#125; = forecast; // change this line // change code above this line return maxOfTomorrow;&#125;console.log(getMaxOfTmrw(LOCAL_FORECAST)); // should be 84.6 Use Destructuring Assignment to Assign Variables from ArraysES6 makes destructuring arrays as easy as destructuring objects. One key difference between the spread operator and array destructuring is that the spread operator unpacks all contents of an array into a comma-separated list. Consequently, you cannot pick or choose which elements you want to assign to variables. Destructuring an array lets us do exactly that: 12const [a, b] = [1, 2, 3, 4, 5, 6];console.log(a, b); // 1, 2 The variable ais assigned the first value of the array, and bis assigned the second value of the array. We can also access the value at any index in an array with destructuring by using commas to reach the desired index: 12const [a, b,,, c] = [1, 2, 3, 4, 5, 6];console.log(a, b, c); // 1, 2, 5 练习123456789let a = 8, b = 6;(() =&gt; &#123; "use strict"; // change code below this line [a,b] = [b,a]; // change code above this line&#125;)();console.log(a); // should be 6console.log(b); // should be 8 Use Destructuring Assignment with the Rest Operator to Reassign Array ElementsIn some situations involving array destructuring, we might want to collect the rest of the elements into a separate array. The result is similar to Array.prototype.slice(), as shown below: 123const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];console.log(a, b); // 1, 2console.log(arr); // [3, 4, 5, 7] Variables aand btake the first and second values from the array. After that, because of rest operator’s presence, arrgets rest of the values in the form of an array. The rest element only works correctly as the last variable in the list. As in, you cannot use the rest operator to catch a subarray that leaves out last element of the original array. 练习1234567891011const source = [1,2,3,4,5,6,7,8,9,10];function removeFirstTwo(list) &#123; "use strict"; // change code below this line const [a,b,...arr] =list // change this // change code above this line return arr;&#125;const arr = removeFirstTwo(source);console.log(arr); // should be [3,4,5,6,7,8,9,10]console.log(source); // should be [1,2,3,4,5,6,7,8,9,10]; Use Destructuring Assignment to Pass an Object as a Function’s ParametersIn some cases, you can destructure the object in a function argument itself. Consider the code below: 1234const profileUpdate = (profileData) =&gt; &#123; const &#123; name, age, nationality, location &#125; = profileData; // do something with these variables&#125; This effectively destructures the object sent into the function. This can also be done in-place: 123const profileUpdate = (&#123; name, age, nationality, location &#125;) =&gt; &#123; /* do something with these fields */&#125; This removes some extra lines and makes our code look neat. This has the added benefit of not having to manipulate an entire object in a function; only the fields that are needed are copied inside the function. 练习12345678910111213const stats = &#123; max: 56.78, standard_deviation: 4.34, median: 34.54, mode: 23.87, min: -0.75, average: 35.85&#125;;// change code below this lineconst half = (&#123;max, min&#125;) =&gt; ((max + min) / 2.0); // use function argument destructurung// change code above this lineconsole.log(stats); // should be objectconsole.log(half(stats)); // should be 28.015 Create Strings using Template LiteralsA new feature of ES6 is the template literal. This is a special type of string that makes creating complex strings easier. Template literals allow you to create multi-line strings and to use string interpolation features to create strings. Consider the code below: 123456789101112const person = &#123; name: "Zodiac Hasbro", age: 56&#125;;// Template literal with multi-line and string interpolationconst greeting = `Hello, my name is $&#123;person.name&#125;!I am $&#123;person.age&#125; years old.`;console.log(greeting); // prints// Hello, my name is Zodiac Hasbro!// I am 56 years old. A lot of things happened there. Firstly, the example uses backticks (not quotes (`'`or `"`), to wrap the string.12345678910111213141516171819202122232425262728293031Secondly, notice that the string is multi-line, both in the code and the output. This saves inserting `\n`within strings.The `$&#123;variable&#125;`syntax used above is a placeholder. Basically, you won&apos;t have to use concatenation with the `+`operator anymore. To add variables to strings, you just drop the variable in a template string and wrap it with `$&#123;`and `&#125;`. Similarly, you can include other expressions in your string literal, for example `$&#123;a + b&#125;`.This new way of creating strings gives you more flexibility to create robust strings.#### 练习```javascriptconst result = &#123; success: [&quot;max-length&quot;, &quot;no-amd&quot;, &quot;prefer-arrow-functions&quot;], failure: [&quot;no-var&quot;, &quot;var-on-top&quot;, &quot;linebreak&quot;], skipped: [&quot;id-blacklist&quot;, &quot;no-dup-keys&quot;]&#125;;function makeList(arr) &#123; &quot;use strict&quot;; const resultDisplayArray = arr.map(val =&gt; `&lt;li class=&quot;text-warning&quot;&gt;$&#123;val&#125;&lt;/li&gt;`); return resultDisplayArray;&#125;/** * makeList(result.failure) should return: * [ `&lt;li class=&quot;text-warning&quot;&gt;no-var&lt;/li&gt;`, * `&lt;li class=&quot;text-warning&quot;&gt;var-on-top&lt;/li&gt;`, * `&lt;li class=&quot;text-warning&quot;&gt;linebreak&lt;/li&gt;` ] **/const resultDisplayArray = makeList(result.failure); Write Concise Object Literal Declarations Using Simple FieldsES6 adds some nice support for easily defining object literals. Consider the following code: 1234const getMousePosition = (x, y) =&gt; (&#123; x: x, y: y&#125;); getMousePositionis a simple function that returns an object containing two fields. ES6 provides the syntactic sugar to eliminate the redundancy of having to write x: x. You can simply write xonce, and it will be converted tox: x(or something equivalent) under the hood. Here is the same function from above rewritten to use this new syntax: 1const getMousePosition = (x, y) =&gt; (&#123; x, y &#125;); 练习12345678const createPerson = (name, age, gender) =&gt; &#123; "use strict"; return &#123; name, age, gender &#125;;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[FCC Basic JS]]></title>
    <url>%2F2019%2F06%2F10%2FFCC-Basic-JS%2F</url>
    <content type="text"><![CDATA[Comment第1种 1//这是注释 第2种 12/* 这是注释 */ VariablesJS有7种数据类型：undefined, null, boolean, string, symbol, number, and object。 定义变量1var 变量名 变量名不可以包含空格，也不可以以1个数字开始。 赋值12345var a;var b = 2;var a = 7;var b = a; 未初始化变量 When JavaScript variables are declared, they have an initial value of undefined. If you do a mathematical operation on an undefinedvariable your result will be NaNwhich means “Not a Number”. If you concatenate a string with an undefinedvariable, you will get a literal string of &quot;undefined&quot;. 1234567var a = 5;var b = 10;var c = "I am a";a = a + 1;b = b + 5;c = c + " String!"; 大小写敏感MYVAR不等于 MyVar或者 myvar。 Write variable names in JavaScript in camelCase. In camelCase, multi-word variable names have the first word in lowercase and the first letter of each subsequent word is capitalized. 建议变量命名使用骆驼峰拼写法camelCase，第一个单词首字母小写，后面的单词首字母大写。 123456789// Declarationsvar studlyCapVar;var properCamelCase;var titleCaseOver;// AssignmentsstudlyCapVar = 10;properCamelCase = "A String";titleCaseOver = 9000; 递增运算符1i++; is the equivalent of 1i = i + 1; 1234var myVar = 87;// Only change code below this linemyVar++; 递减运算符1234var myVar = 11;// Only change code below this linemyVar--; 十进制数值 Decimal Numbers Decimal numbers are sometimes referred to as floating pointnumbers or floats. 余数 The remainder operator is sometimes incorrectly referred to as the “modulus” operator. It is very similar to modulus, but does not work properly with negative numbers. 12var remainder;remainder = 11 % 3; 复合赋值运算符Augmented Addition123var myVar = 1;myVar += 5;console.log(myVar); // Returns 6 1myVar = myVar + 5; 123456789var a = 3;var b = 17;var c = 12;// Only modify code below this linea += 12;b += 9;c += 7; Augmented Subtraction1myVar -= 5; 1myVar = myVar - 5; Augmented Multiplication1myVar *= 5; 1myVar = myVar * 5; Augmented Division1myVar /= 5; 1myVar = myVar / 5; 转义引号引号前面使用 反斜杠 (\) backslash 来转义引号。 1var sampleStr = "Alan said, \"Peter is learning JavaScript\"."; 1var myStr = "I am a \"double quoted\" string inside \"double quotes\"."; 单引号1var myStr = '&lt;a href="http://www.example.com" target="_blank"&gt;Link&lt;/a&gt;'; 转义序列列表 Code Output \&#39; single quote \&quot; double quote \\ backslash(反斜杠符) \n newline(换行符) \r carriage return(回车符) \t tab(制表符) \b backspace(退格符) \f form feed(换页符) Note that the backslash itself must be escaped in order to display as a backslash. 如果你想要显示一个反斜杠就必须要转义它。 1var myStr = 'FirstLine\n\t\\SecondLine\nThirdLine'; 连接符1var myStr = "This is the start. " + "This is the end."; 长字符串12var myStr = "This is the first sentence. ";myStr += "This is the second sentence."; 字符串值长度.length属性 1lastNameLength = lastName.length; 索引（Bracket Notation）1firstLetterOfLastName = lastName[0]; 不可改变的字符串In JavaScript, Stringvalues are immutable, which means that they cannot be altered once created. 改变 myStr 中的唯一方法是重新给它赋一个值，就像这样： var myStr = “Bob”;myStr = “Job”; 最后字符串1var lastLetterOfLastName = lastName[lastName.length - 1]; Word Blanks123456789function wordBlanks(myNoun, myAdjective, myVerb, myAdverb) &#123; var result = "";result += "My "+myAdjective+" "+myNoun+" "+myVerb+" very "+myAdverb+"."; return result;&#125;wordBlanks("dog", "big", "ran", "quickly"); 列表1var sandwich = ["peanut butter", "jelly", "bread"] nested array1var ourArray = [["the universe", 42], ["everything", 101010]]; Modify Array Data With Indexes123456var ourArray = [18,64,99];ourArray[1] = 45; // ourArray now equals [18,45,99].// Setupvar myArray = [18,64,99];myArray[0] = 45; 多维数组123456789var arr = [ [1,2,3], [4,5,6], [7,8,9], [[10,11,12], 13, 14]];arr[0]; // 等于 [1,2,3]arr[1][2]; // 等于 6arr[3][0][1]; // 等于 11 push函数123var arr = [1,2,3];arr.push(4);// arr is now [1,2,3,4] pop函数1234var threeArr = [1, 4, 6];var oneDown = threeArr.pop();console.log(oneDown); // Returns 6console.log(threeArr); // Returns [1, 4] shift函数remove first 1234var ourArray = ["Stimpson", "J", ["cat"]];var removedFromOurArray = ourArray.shift();// removedFromOurArray now equals "Stimpson" and ourArray now equals ["J", ["cat"]]. unshift函数向数组的开头添加元素 12345var ourArray = ["Stimpson", "J", "cat"];ourArray.shift(); // ourArray now equals ["J", "cat"]ourArray.unshift("Happy"); // ourArray now equals ["Happy", "J", "cat"] Reusable Functions123function functionName() &#123; console.log("Hello World");&#125; Passing Values to Functions with Arguments123function testFun(param1, param2) &#123; console.log(param1, param2);&#125; Parameters are variables that act as placeholders for the values that are to be input to a function when it is called. When a function is defined, it is typically defined along with one or more parameters. The actual values that are input (or “passed”) into a function when it is called are known as arguments. 函数的参数parameters在函数中充当占位符(也叫形参)的作用，参数可以为一个或多个。调用一个函数时所传入的参数为实参，实参决定着形参真正的值。简单理解：形参即形式、实参即内容。 1234function functionWithArgs(a, b)&#123; console.log(a + b);&#125;functionWithArgs(1, 2); Global Scope and Functions 全局作用域In JavaScript, scope refers to the visibility of variables. Variables which are defined outside of a function block have Global scope. This means, they can be seen everywhere in your JavaScript code. Variables which are used without the varkeyword are automatically created in the globalscope. This can create unintended consequences elsewhere in your code or when running a function again. You should always declare your variables with var. 在 JavaScript 中， 作用域 涉及到变量的作用范围。在函数外定义的变量具有 全局 作用域。这意味着，具有全局作用域的变量可以在代码的任何地方被调用。 这些没有使用var关键字定义的变量，会被自动创建在全局作用域中，形成全局变量。当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。因此你应该总是使用var关键字来声明你的变量。 12345678910111213141516var myGlobal = 10;function fun1() &#123; oopsGlobal = 5;&#125;function fun2() &#123; var output = ""; if (typeof myGlobal != "undefined") &#123; output += "myGlobal: " + myGlobal; &#125; if (typeof oopsGlobal != "undefined") &#123; output += " oopsGlobal: " + oopsGlobal; &#125; console.log(output);&#125; Local Scope and FunctionsVariables which are declared within a function, as well as the function parameters have local scope. That means, they are only visible within that function. 在一个函数内声明的变量，以及该函数的参数都是局部变量，意味着它们只在该函数内可见。 这是在函数 myTest内声明局部变量loc 的最佳例子： 123456function myTest() &#123; var loc = "foo"; console.log(loc);&#125;myTest(); // logs "foo"console.log(loc); // loc is not defined locis not defined outside of the function. 在函数外，loc 是未定义的。 1234567function myFunction() &#123; 'use strict'; var myVar = "pikapika"; console.log(myVar);&#125;myFunction(); Global vs. Local Scope in FunctionsIt is possible to have both local and global variables with the same name. When you do this, the localvariable takes precedence over the globalvariable. 一个程序中有可能具有相同名称的 局部 变量 和 全局变量。在这种情况下，局部 变量将会优先于 全局 变量。 In this example: 12345var someVar = "Hat";function myFun() &#123; var someVar = "Head"; return someVar;&#125; The function myFunwill return &quot;Head&quot;because the localversion of the variable is present. 函数 myFun 将会返回 &quot;Head&quot;，因为 局部变量 优先级更高。 12345678var outerWear = "T-Shirt";function myOutfit() &#123; var outerWear = "sweater"; return outerWear;&#125;myOutfit(); Return a Value from a Function with ReturnWe can pass values into a function with arguments. You can use a returnstatement to send a value back out of a function. 我们可以把数据通过函数的 参数 来传入函数，也可以使用 return 语句把数据从一个函数中传出来。 1234function plusThree(num) &#123; return num + 3;&#125;var answer = plusThree(5); // 8 plusThreetakes an argument for numand returns a value equal to num + 3. plusThree 带有一个为 num 的 参数 并且返回（returns）一个等于 num + 3 的值。 12345678910function minusSeven(num) &#123; return num - 7;&#125;function timesFive(num)&#123; return num * 5;&#125;console.log(minusSeven(10)); Understanding Undefined Value returned from a FunctionA function can include the returnstatement but it does not have to. In the case that the function doesn’t have a returnstatement, when you call it, the function processes the inner code but the returned value is undefined. 12345var sum = 0;function addSum(num) &#123; sum = sum + num;&#125;var returnedValue = addSum(3); // sum will be modified but returned value is undefined addSumis a function without a returnstatement. The function will change the global sumvariable but the returned value of the function is undefined Create a function addFivewithout any arguments. This function adds 5 to the sumvariable, but its returned value is undefined. 1234567891011var sum = 0;function addThree() &#123; sum = sum + 3;&#125;function addFive()&#123; sum += 5;&#125;var returnedValue = addFive(); Assignment with a Returned ValueIf you’ll recall from our discussion of Storing Values with the Assignment Operator, everything to the right of the equal sign is resolved before the value is assigned. This means we can take the return value of a function and assign it to a variable. 如果你还记得我们在这一节 Storing Values with the Equal Operator 的讨论，赋值之前，先完成等号右边的操作。这意味着我们可把一个函数的返回值，赋值给一个变量。 Assume we have pre-defined a function sumwhich adds two numbers together, then: 假设我们预先定义的函数 sum 其功能就是将两个数字相加，那么： 1ourSum = sum(5, 12); will call sumfunction, which returns a value of 17and assigns it to ourSumvariable. 将调用 sum 函数，返回return了一个数值 17，然后把它赋值给了 ourSum 变量。 练习： 1234567891011121314151617var changed = 0;function change(num) &#123; return (num + 5) / 3;&#125;changed = change(10);var processed = 0;function processArg(num) &#123; return (num + 3) / 5;&#125;processed = processArg(7); Stand in LineIn Computer Science a queue is an abstract Data Structure where items are kept in order. New items can be added at the back of the queueand old items are taken off from the front of the queue. Write a function nextInLinewhich takes an array (arr) and a number (item) as arguments. Add the number to the end of the array, then remove the first element of the array. The nextInLinefunction should then return the element that was removed. 在计算机科学中 队列（queue）是一个抽象的数据结构，队列中的条目都是有秩序的。新的条目会被加到 队列 的末尾，旧的条目会从 队列 的头部被移出。 写一个函数 queue ，用一个数组arr和一个数字item作为参数。数字item添加到数组的结尾，然后移出数组的第一个元素，最后队列函数应该返回被删除的元素。 1234567891011121314function nextInLine(arr, item) &#123; // Your code here arr.push(item); var item = arr.shift(); return item; // Change this line&#125;// Test Setupvar testArr = [1,2,3,4,5];// Display Codeconsole.log("Before: " + JSON.stringify(testArr));console.log(nextInLine(testArr, 6)); // Modify this line to testconsole.log("After: " + JSON.stringify(testArr)); BooleanAnother data type is the Boolean. Booleansmay only be one of two values: trueor false. They are basically little on-off switches, where trueis “on” and falseis “off.” These two states are mutually exclusive. 另一种数据类型是布尔（Boolean）。布尔 值要么是true 要么是false。它非常像电路开关， true是“开”，false 是“关”。这两种状态是互斥的。 注意Boolean 值绝不会写作被引号包裹起来的形式。字符串的 &quot;true&quot; 和 &quot;false&quot; 不是 布尔值，在 JavaScript 中也没有特殊含义。 NoteBooleanvalues are never written with quotes. The strings`“true”and“false”are notBoolean`and have no special meaning in JavaScript. 练习： 123function welcomeToBooleans() &#123;return true; &#125; If StatementsIfstatements are used to make decisions in code. The keyword iftells JavaScript to execute the code in the curly braces under certain conditions, defined in the parentheses. These conditions are known as Booleanconditions and they may only be trueor false. When the condition evaluates to true, the program executes the statement inside the curly braces. When the Boolean condition evaluates to false, the statement inside the curly braces will not execute. If 语句用于在代码中做条件判断。关键字 if 告诉 JavaScript 在小括号中的条件为真的情况下去执行定义在大括号里面的代码。这种条件被称为 Boolean 条件，因为他们只可能是 true（真）或 false（假）。 当条件的计算结果为 true，程序执行大括号内的语句。当布尔条件的计算结果为 false，大括号内的代码将不会执行。 Pseudocode 123if (condition is true) &#123; statement is executed&#125; 12345678function test (myCondition) &#123; if (myCondition) &#123; return "It was true"; &#125; return "It was false";&#125;test(true); // returns "It was true"test(false); // returns "It was false" When testis called with a value of true, the ifstatement evaluates myConditionto see if it is trueor not. Since it is true, the function returns &quot;It was true&quot;. When we call testwith a value of false, myConditionis not trueand the statement in the curly braces is not executed and the function returns &quot;It was false&quot;. 当 test 被调用，并且传递进来的参数值为 true，if语句会计算 myCondition 的结果，看它是真还是假。如果条件为 true，函数会返回 &quot;It was true&quot;。当 test 被调用，并且传递进来的参数值为 false，myCondition 不 为 true，并且不执行大括号后面的语句，函数返回 &quot;It was false&quot;。 练习： Create an ifstatement inside the function to return &quot;Yes, that was true&quot;if the parameter wasThatTrueis trueand return &quot;No, that was false&quot;otherwise. 123456789101112131415function ourTrueOrFalse(isItTrue) &#123; if (isItTrue) &#123; return "Yes, it's true"; &#125; return "No, it's false";&#125;function trueOrFalse(wasThatTrue) &#123; if(wasThatTrue)&#123; return "Yes, that was true"; &#125; return "No, that was false";&#125;trueOrFalse(false); Equality Operator 相等运算符here are many Comparison Operators in JavaScript. All of these operators return a boolean trueor falsevalue. The most basic operator is the equality operator ==. The equality operator compares two values and returns trueif they’re equivalent or falseif they are not. Note that equality is different from assignment (=), which assigns the value at the right of the operator to a variable in the left. 在 JavaScript 中，有很多 相互比较的操作。所有这些操作符都返回一个 true 或 false 值。 最基本的运算符是相等运算符：==。相等运算符比较两个值，如果它们是同等，返回 true，如果它们不等，返回 false。值得注意的是相等运算符不同于赋值运算符（=），赋值运算符是把等号右边的值赋给左边的变量。 123456function equalityTest(myVal) &#123; if (myVal == 10) &#123; return "Equal"; &#125; return "Not Equal";&#125; If myValis equal to 10, the equality operator returns true, so the code in the curly braces will execute, and the function will return &quot;Equal&quot;. Otherwise, the function will return &quot;Not Equal&quot;. In order for JavaScript to compare two different data types(for example, numbersand strings), it must convert one type to another. This is known as “Type Coercion”. Once it does, however, it can compare terms as follows: 如果 myVal 等于 10，相等运算符会返回 true，因此大括号里面的代码会被执行，函数将返回 &quot;Equal&quot;。否则，函数返回 &quot;Not Equal&quot;。 在 JavaScript 中，为了让两个不同的 数据类型（例如 数字 和 字符串）的值可以作比较，它必须把一种类型转换为另一种类型。然而一旦这样做，它可以像下面这样来比较： 12341 == 1 // true1 == 2 // false1 == '1' // true"3" == 3 // true 练习： 12345678function myTest(val) &#123; if (val == 12) &#123; return "Equal"; &#125; return "Not Equal";&#125;myTest(10); Strict Equality Operator 严格相等运算符Strict equality (===) is the counterpart to the equality operator (==). However, unlike the equality operator, which attempts to convert both values being compared to a common type, the strict equality operator does not perform a type conversion. If the values being compared have different types, they are considered unequal, and the strict equality operator will return false. 严格相等运算符（===）是相对于相等操作符（==）的一种操作符。与相等操作符不同的是，它会同时比较元素的值和 数据类型。 Examples 123 === 3 // true3 === '3' // false In the second example, 3is a Numbertype and &#39;3&#39;is a Stringtype. 练习： 12345678function testStrict(val) &#123; if (val === 7) &#123; return "Equal"; &#125; return "Not Equal";&#125;testStrict(10); Practice comparing different valuesIn the last two challenges, we learned about the equality operator (==) and the strict equality operator (===). Let’s do a quick review and practice using these operators some more. If the values being compared are not of the same type, the equality operator will perform a type conversion, and then evaluate the values. However, the strict equality operator will compare both the data type and value as-is, without converting one type to the other. 123 == '3' // returns true because JavaScript performs type conversion from string to number3 === '3' // returns false because the types are different and type conversion is not performed NoteIn JavaScript, you can determine the type of a variable or a value with the typeofoperator, as follows: 12typeof 3 // returns 'number'typeof '3' // returns 'string' 练习： The compareEqualityfunction in the editor compares two values using the equality operator. Modify the function so that it returns “Equal” only when the values are strictly equal. 12345678function compareEquality(a, b) &#123; if (a === b) &#123; return "Equal"; &#125; return "Not Equal";&#125;compareEquality(10, "10"); Inequality Operator 不相等运算符The inequality operator (!=) is the opposite of the equality operator. It means “Not Equal” and returns falsewhere equality would return trueand vice versa. Like the equality operator, the inequality operator will convert data types of values while comparing. 不相等运算符（!=）与相等运算符是相反的。这意味着不相等运算符中，如果“不为真”并且返回 false的地方，在相等运算符中会返回true，反之亦然。与相等运算符类似，不相等运算符在比较的时候也会转换值的数据类型。 123451 != 2 // true1 != "1" // false1 != '1' // false1 != true // false0 != false // false 12345678function testNotEqual(val) &#123; if (val != 99) &#123; return "Not Equal"; &#125; return "Equal";&#125;testNotEqual(10); Strict Inequality Operator 严格相等运算符The strict inequality operator (!==) is the logical opposite of the strict equality operator. It means “Strictly Not Equal” and returns falsewhere strict equality would return trueand vice versa. Strict inequality will not convert data types. 严格相等运算符（===）是相对于相等操作符（==）的一种操作符。与相等操作符不同的是，它会同时比较元素的值和 数据类型。 123 === 3 // true3 === '3' // false 3 是一个 数字 类型的，而&#39;3&#39; 是一个 字符 类型的，所以3不全等于’3’。 the Greater Than Operator 大于运算符The greater than operator (&gt;) compares the values of two numbers. If the number to the left is greater than the number to the right, it returns true. Otherwise, it returns false. Like the equality operator, greater than operator will convert data types of values while comparing. 使用大于运算符（&gt;）来比较两个数字。如果大于运算符左边的数字大于右边的数字，将会返回 true。否则，它返回 false。 与相等运算符一样，大于运算符在比较的时候，会转换值的数据类型。 1234 5 &gt; 3 // true 7 &gt; '3' // true 2 &gt; 3 // false'1' &gt; 9 // false the Greater Than Or Equal To Operator 大于等于运算符The greater than or equal tooperator (&gt;=) compares the values of two numbers. If the number to the left is greater than or equal to the number to the right, it returns true. Otherwise, it returns false. Like the equality operator, greater than or equal tooperator will convert data types while comparing. 使用 大于等于 运算符（&gt;=）来比较两个数字的大小。如果大于等于运算符左边的数字比右边的数字大或者相等，它会返回 true。否则，它会返回 false。 与相等运算符相似，大于等于 运算符在比较的时候会转换值的数据类型。 1234 6 &gt;= 6 // true 7 &gt;= '3' // true 2 &gt;= 3 // false'7' &gt;= 9 // false the Less Than Operator 小于运算符The less than operator (&lt;) compares the values of two numbers. If the number to the left is less than the number to the right, it returns true. Otherwise, it returns false. Like the equality operator, less thanoperator converts data types while comparing. 使用 小于 运算符（&lt;）比较两个数字的大小。如果小于运算符左边的数字比右边的数字小，它会返回 true。否则，他会返回 false。与相等运算符类似，小于 运算符在做比较的时候会转换值的数据类型。 123452 &lt; 5 // true'3' &lt; 7 // true5 &lt; 5 // false3 &lt; 2 // false'8' &lt; 4 // false the Less Than Or Equal To Operator 小于等于运算符The less than or equal tooperator (&lt;=) compares the values of two numbers. If the number to the left is less than or equal to the number to the right, it returns true. If the number on the left is greater than the number on the right, it returns false. Like the equality operator, less than or equal toconverts data types. 123454 &lt;= 5 // true'7' &lt;= 7 // true5 &lt;= 5 // true3 &lt;= 2 // false'8' &lt;= 4 // false the Logical And OperatorSometimes you will need to test more than one thing at a time. The logical and operator (&amp;&amp;) returns trueif and only if the operands to the left and right of it are true. The same effect could be achieved by nesting an if statement inside another if: 有时你需要在一次判断中做多个操作。当且仅当运算符的左边和右边都是 true，逻辑与 运算符（&amp;&amp;）才会返回 true。 123456if (num &gt; 5) &#123; if (num &lt; 10) &#123; return "Yes"; &#125;&#125;return "No"; will only return “Yes” if numis greater than 5and less than 10. The same logic can be written as: 只有当 num 的值在6和9之间（包括6和9）才会返回 “Yes”。相同的逻辑可被写为： 1234if (num &gt; 5 &amp;&amp; num &lt; 10) &#123; return "Yes";&#125;return "No"; the Logical Or OperatorThe logical or operator (||) returns trueif either of the operands is true. Otherwise, it returns false. 如果任何一个操作数是true，逻辑或 运算符 (||) 返回 true。反之，返回 false。 The logical or operator is composed of two pipe symbols (|). This can typically be found between your Backspace and Enter keys. The pattern below should look familiar from prior waypoints: 1234567if (num &gt; 10) &#123; return "No";&#125;if (num &lt; 5) &#123; return "No";&#125;return "Yes"; will return “Yes” only if numis between 5and 10(5 and 10 included). The same logic can be written as: 只有当num大于等于5或小于等于10时，函数返回”Yes”。相同的逻辑可以简写成： 1234if (num &gt; 10 || num &lt; 5) &#123; return "No";&#125;return "Yes"; 练习： 123456789function testLogicalOr(val) &#123; if (val &gt;= 21 || val &lt; 10) &#123; return "Outside"; &#125; return "Inside";&#125;testLogicalOr(15); Introducing Else StatementsWhen a condition for an ifstatement is true, the block of code following it is executed. What about when that condition is false? Normally nothing would happen. With an elsestatement, an alternate block of code can be executed. 当if语句的条件为真，大括号里的代码执行，那如果条件为假呢？ 正常情况下什么也不会发生。 写一个else语句，当条件为假时执行相应的代码。 12345if (num &gt; 10) &#123; return "Bigger than 10";&#125; else &#123; return "10 or Less";&#125; 12345678910111213function testElse(val) &#123; var result = ""; if (val &gt; 5) &#123; result = "Bigger than 5"; &#125; else &#123; return "5 or Smaller"; &#125; return result;&#125;testElse(4); Else If StatementsIf you have multiple conditions that need to be addressed, you can chain ifstatements together with else ifstatements. 如果你有多个条件语句，你可以通过else if语句把 if语句链起来。 1234567if (num &gt; 15) &#123; return "Bigger than 15";&#125; else if (num &lt; 5) &#123; return "Smaller than 5";&#125; else &#123; return "Between 5 and 15";&#125; 123456789101112function testElseIf(val) &#123; if (val &gt; 10) &#123; return "Greater than 10"; &#125; else if (val &lt; 5)&#123; return "Smaller than 5"; &#125; else &#123; return "Between 5 and 10"; &#125;&#125;// Change this value to testtestElseIf(7); Logical Order in If Else StatementsOrder is important in if, else ifstatements. The function is executed from top to bottom so you will want to be careful of what statement comes first. if、else if语句中代码的执行顺序是很重要的。 在条件判断语句中，代码的执行顺序是从上到下，所以你需要考虑清楚先执行哪一句，后执行哪一句。 Take these two functions as an example. Here’s the first: 123456789function foo(x) &#123; if (x &lt; 1) &#123; return "Less than one"; &#125; else if (x &lt; 2) &#123; return "Less than two"; &#125; else &#123; return "Greater than or equal to two"; &#125;&#125; And the second just switches the order of the statements: 第二个例子更改了代码的执行顺序： 123456789function bar(x) &#123; if (x &lt; 2) &#123; return "Less than two"; &#125; else if (x &lt; 1) &#123; return "Less than one"; &#125; else &#123; return "Greater than or equal to two"; &#125;&#125; While these two functions look nearly identical if we pass a number to both we get different outputs. 这两个函数看起来几乎一模一样，我们传一个值进去看看它们有什么区别。 12foo(0) // "Less than one"bar(0) // "Less than two" 练习： 123456789101112function orderMyLogic(val) &#123; if (val &lt; 5) &#123; return "Less than 5"; &#125; else if (val &lt; 10) &#123; return "Less than 10"; &#125; else &#123; return "Greater than or equal to 10"; &#125;&#125;// Change this value to testorderMyLogic(7); Chaining If Else Statementsif/elsestatements can be chained together for complex logic. Here is pseudocode of multiple chained if/ else ifstatements: if/else 语句串联在一起可以实现复杂的逻辑，这是多个if/else if 语句串联在一起的伪代码： 12345678910if (condition1) &#123; statement1&#125; else if (condition2) &#123; statement2&#125; else if (condition3) &#123; statement3. . .&#125; else &#123; statementN&#125; Write chained if/else ifstatements to fulfill the following conditions: 把if/else if语句串联起来实现下面的逻辑： num &lt; 5- return “Tiny”num &lt; 10- return “Small”num &lt; 15- return “Medium”num &lt; 20- return “Large”num &gt;= 20- return “Huge” 1234567891011121314151617181920function testSize(num) &#123; // Only change code below this line if(num&lt;5)&#123; return "Tiny" &#125;else if(num&lt;10)&#123; return "Small" &#125;else if(num&lt;15)&#123; return "Medium" &#125;else if(num&lt;20)&#123; return "Large" &#125;else&#123; return "Huge" &#125; return "Change Me"; // Only change code above this line&#125;// Change this value to testtestSize(7); Golf CodeIn the game of golf each hole has a parmeaning the average number of strokesa golfer is expected to make in order to sink the ball in a hole to complete the play. Depending on how far above or below paryour strokesare, there is a different nickname. Your function will be passed parand strokesarguments. Return the correct string according to this table which lists the strokes in order of priority; top (highest) to bottom (lowest): 在高尔夫golf游戏中，每个洞都有自己的标准杆数par，代表着距离。根据你把球打进洞所挥杆的次数strokes，可以计算出你的高尔夫水平。 函数将会传送2个参数，分别是标准杆数par 和 挥杆次数strokes ，根据下面的表格返回正确的水平段位。 Strokes Return 1 “Hole-in-one!” &lt;= par - 2 “Eagle” par - 1 “Birdie” par “Par” par + 1 “Bogey” par + 2 “Double Bogey” &gt;= par + 3 “Go Home!” parand strokeswill always be numeric and positive. We have added an array of all the names for your convenience. par 和 strokes 必须是数字而且是正数。 12345678910111213141516171819202122232425var names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!"];function golfScore(par, strokes) &#123; // Only change code below this line if (strokes === 1)&#123; return "Hole-in-one!"; &#125; else if (strokes &lt;= par - 2)&#123; return "Eagle"; &#125; else if (strokes === par - 1) &#123; return "Birdie"; &#125; else if (strokes === par) &#123; return "Par"; &#125; else if (strokes === par + 1) &#123; return "Bogey"; &#125; else if (strokes === par + 2) &#123; return "Double Bogey"; &#125; else if (strokes &gt;= par + 3) &#123; return "Go Home!"; &#125; return "Change Me"; // Only change code above this line&#125;// Change these values to testgolfScore(5, 4); Switch StatementsIf you have many options to choose from, use a switchstatement. A switchstatement tests a value and can have many casestatements which define various possible values. Statements are executed from the first matched casevalue until a breakis encountered. 如果你有非常多的选项需要选择，可以使用switch语句。根据不同的参数值会匹配上不同的case分支，语句会从第一个匹配的case分支开始执行，直到碰到break就结束。 Here is a pseudocode example: 123456789101112switch(num) &#123; case value1: statement1; break; case value2: statement2; break;... case valueN: statementN; break;&#125; casevalues are tested with strict equality (===). The breaktells JavaScript to stop executing statements. If the breakis omitted, the next statement will be executed. 测试case 值使用严格相等运算符进行比较，break关键字告诉javascript停止执行语句。如果没有break关键字，下一个语句会继续执行。 Write a switch statement which tests valand sets answerfor the following conditions: 写一个测试 val的switch语句，并且根据下面的条件来设置不同的answer： 1- “alpha”2- “beta”3- “gamma”4- “delta” 123456789101112131415161718192021222324function caseInSwitch(val) &#123; var answer = ""; // Only change code below this line switch (val)&#123; case 1: answer = "alpha"; break; case 2: answer = "beta"; break; case 3: answer = "gamma"; break; case 4: answer = "delta"; break; &#125; // Only change code above this line return answer; &#125;// Change this value to testcaseInSwitch(1); Adding a Default Option in Switch StatementsIn a switchstatement you may not be able to specify all possible values as casestatements. Instead, you can add the defaultstatement which will be executed if no matching casestatements are found. Think of it like the final elsestatement in an if/elsechain. 在switch 语句中你可能无法用case来指定所有情况，这时你可以添加default语句。当再也找不到case匹配的时候default语句会执行，非常类似于if/else组合中的else语句。 A defaultstatement should be the last case. 123456789101112switch (num) &#123; case value1: statement1; break; case value2: statement2; break;... default: defaultStatement; break;&#125; Write a switch statement to set answerfor the following conditions:&quot;a&quot;- “apple”&quot;b&quot;- “bird”&quot;c&quot;- “cat”default- “stuff” 12345678910111213141516171819202122function myTest(val) &#123; var answer = ""; switch (val)&#123; case "a": answer = "apple"; break; case "b": answer = "bird"; break; case "c": answer = "cat"; break; default: answer = "stuff"; &#125; return answer; &#125;myTest(1); Multiple Identical Options in Switch StatementsIf the breakstatement is omitted from a switchstatement’s case, the following casestatement(s) are executed until a breakis encountered. If you have multiple inputs with the same output, you can represent them in a switchstatement like this: 如果switch语句中的case分支的break 语句漏掉了，后面的 case语句会一直执行直到遇到break。如果你有多个输入值和输出值一样，可以试试下面的switch语句： 123456789switch(val) &#123; case 1: case 2: case 3: result = "1, 2, or 3"; break; case 4: result = "4 alone";&#125; Cases for 1, 2, and 3 will all produce the same result. 分支1、2、3将会产生相同的输出结果。 Write a switch statement to set answerfor the following ranges:1-3- “Low”4-6- “Mid”7-9- “High” NoteYou will need to have a casestatement for each number in the range. 123456789101112131415161718192021222324252627function sequentialSizes(val) &#123; var answer = ""; // Only change code below this line switch (val) &#123; case 1: case 2: case 3: answer = "Low"; break; case 4: case 5: case 6: answer = "Mid"; break; case 7: case 8: case 9: answer = "High"; break; &#125; // Only change code above this line return answer; &#125;// Change this value to testsequentialSizes(1); Replacing If Else Chains with SwitchIf you have many options to choose from, a switchstatement can be easier to write than many chained if/else ifstatements. The following: 1234567if (val === 1) &#123; answer = "a";&#125; else if (val === 2) &#123; answer = "b";&#125; else &#123; answer = "c";&#125; can be replaced with: 12345678910switch(val) &#123; case 1: answer = "a"; break; case 2: answer = "b"; break; default: answer = "c";&#125; 练习： 123456789101112131415161718192021222324252627282930function chainToSwitch(val) &#123; var answer = ""; // Only change code below this line switch (val) &#123; case "bob": answer = "Marley"; break; case 42: answer = "The Answer"; break; case 1: answer = "There is no #1"; break; case 99: answer = "Missed me by this much!"; break; case 7: answer = "Ate Nine"; break; default: answer = ""; &#125; // Only change code above this line return answer; &#125;// Change this value to testchainToSwitch(7); Returning Boolean Values from FunctionsYou may recall from Comparison with the Equality Operator that all comparison operators return a boolean trueor falsevalue. Sometimes people use an if/else statement to do a comparison, like this: 你可能会回想起Comparison with the Equality Operator ，所有的比较操作符返回的都是一个boolean值，要么是 true 要么是false 。 使用 if/else语句来做比较然后返回true或false已经成为大家的共识: 1234567function isEqual(a,b) &#123; if (a === b) &#123; return true; &#125; else &#123; return false; &#125;&#125; But there’s a better way to do this. Since ===returns trueor false, we can return the result of the comparison: 因为=== 总是返回 true 或 false，所以我们可以直接返回比较的结果： 123function isEqual(a,b) &#123; return a === b;&#125; 练习： 123456function isLess(a, b) &#123; // Fix this code return a &lt; b;&#125;// Change these values to testisLess(10, 15); Return Early Pattern for FunctionsWhen a returnstatement is reached, the execution of the current function stops and control returns to the calling location. 当代码执行到return语句时，函数返回一个结果就结束运行了，return后面的语句根本不会执行。 123456function myFun() &#123; console.log("Hello"); return "World"; console.log("byebye")&#125;myFun(); The above outputs “Hello” to the console, returns “World”, but &quot;byebye&quot;is never output, because the function exits at the returnstatement. 上面的代码输出”Hello”到控制台、返回 “World”，但没有输出&quot;byebye&quot;，因为函数遇到return语句就退出了。 Modify the function abTestso that if aor bare less than 0the function will immediately exit with a value of undefined. 修改函数abTest当a或b小于0时，函数立即返回一个undefined并退出。 HintRemember that undefinedis a keyword, not a string. 12345678function abTest(a, b) &#123; if (a &lt; 0 || b &lt;0) return undefined; return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2));&#125;abTest(2,2); Counting CardsIn the casino game Blackjack, a player can gain an advantage over the house by keeping track of the relative number of high and low cards remaining in the deck. This is called Card Counting. Having more high cards remaining in the deck favors the player. Each card is assigned a value according to the table below. When the count is positive, the player should bet high. When the count is zero or negative, the player should bet low. 在赌场21点游戏中，玩家可以通过计算牌桌上已经发放的卡牌的高低值来让自己在游戏中保持优势，这就叫21点算法。 根据下面的表格，每张卡牌都分配了一个值。如果卡牌的值大于0，那么玩家应该追加赌注。反之，追加少许赌注甚至不追加赌注。 Count Change Cards +1 2, 3, 4, 5, 6 0 7, 8, 9 -1 10, ‘J’, ‘Q’, ‘K’, ‘A’ You will write a card counting function. It will receive a cardparameter, which can be a number or a string, and increment or decrement the global countvariable according to the card’s value (see table). The function will then return a string with the current count and the string Betif the count is positive, or Holdif the count is zero or negative. The current count and the player’s decision (Betor Hold) should be separated by a single space. 你需要写一个函数，实现21点算法，它根据参数 card的值来递增或递减变量count，函数返回一个由当前count和 &quot;Bet&quot;(count&gt;0)或&quot;Hold&quot;(count&lt;=0) 拼接的字符串。注意count和&quot;Bet&quot; 或 &quot;Hold&quot;应该用空格分开。 Example Output-3 Hold5 Bet HintDo NOT reset countto 0 when value is 7, 8, or 9.Do NOT return an array.Do NOT include quotes (single or double) in the output. 12345678910111213141516171819202122232425262728293031var count = 0;function cc(card) &#123; switch(card)&#123; case 2: case 3: case 4: case 5: case 6: count++; break; case 10: case "J": case "Q": case "K": case "A": count--; break; &#125; if (count &gt; 0)&#123; return count + " Bet"; &#125; else &#123; return count + " Hold"; &#125; return "Change Me";&#125;// Add/remove calls to test your function.// Note: Only the last will displaycc(2); cc(3); cc(7); cc('K'); cc('A'); 创建JS对象对象和数组很相似，数组是通过索引来访问和修改数据，对象是通过属性来访问和修改数据的。 123456var cat = &#123; "name": "Whiskers", "legs": 4, "tails": 1, "enemies": ["Water", "Dogs"]&#125;; In this example, all the properties are stored as strings, such as - &quot;name&quot;, &quot;legs&quot;, and &quot;tails&quot;. However, you can also use numbers as properties. You can even omit the quotes for single-word string properties, as follows: 12345var anotherObject = &#123; make: "Ford", 5: "five", "model": "focus"&#125;; However, if your object has any non-string properties, JavaScript will automatically typecast them as strings. 123456789101112131415var ourDog = &#123; "name": "Camper", "legs": 4, "tails": 1, "friends": ["everything!"]&#125;;// Only change code below this line.var myDog = &#123; "name": "Dong", "legs": 2, "tails": 1, "friends":["wholeworld"] &#125;; Accessing Object Properties with Dot NotationThere are two ways to access the properties of an object: dot notation (.) and bracket notation ([]), similar to an array. Dot notation is what you use when you know the name of the property you’re trying to access ahead of time. Here is a sample of using dot notation (.) to read an object’s property: 有两种方式访问对象属性，一个是点操作符(.)，一个是中括号操作符([])。 当你知道属性的名称的时候，使用点操作符。 这是一个使用点操作符读取对象属性的例子： 123456var myObj = &#123; prop1: "val1", prop2: "val2"&#125;;var prop1val = myObj.prop1; // val1var prop2val = myObj.prop2; // val2 12345678910var testObj = &#123; "hat": "ballcap", "shirt": "jersey", "shoes": "cleats"&#125;;// Only change code below this linevar hatValue = testObj.hat; // Change this linevar shirtValue = testObj.shirt; // Change this line Accessing Object Properties with Bracket NotationThe second way to access the properties of an object is bracket notation ([]). If the property of the object you are trying to access has a space in its name, you will need to use bracket notation. However, you can still use bracket notation on object properties without spaces. Here is a sample of using bracket notation to read an object’s property: 第二种访问对象的方式就是中括号操作符([])，如果你想访问的属性的名称有一个空格，这时你只能使用中括号操作符([])。 这是一个使用中括号操作符([])读取对象属性的例子： 12345678var myObj = &#123; "Space Name": "Kirk", "More Space": "Spock", "NoSpace": "USS Enterprise"&#125;;myObj["Space Name"]; // KirkmyObj['More Space']; // SpockmyObj["NoSpace"]; // USS Enterprise Note that property names with spaces in them must be in quotes (single or double). 12345678var testObj = &#123; "an entree": "hamburger", "my side": "veggies", "the drink": "water"&#125;;var entreeValue=testObj["an entree"]; var drinkValue=testObj["the drink"]; Accessing Object Properties with VariablesAnother use of bracket notation on objects is to access a property which is stored as the value of a variable. This can be very useful for iterating through an object’s properties or when accessing a lookup table. Here is an example of using a variable to access a property: 中括号操作符的另一个使用方式是用变量来访问一个属性。当你需要遍历对象的属性列表或查表时，这种方式极为有用。 这有一个使用变量来访问属性的例子： 123456var dogs = &#123; Fido: "Mutt", Hunter: "Doberman", Snoopie: "Beagle"&#125;;var myDog = "Hunter";var myBreed = dogs[myDog];console.log(myBreed); // "Doberman" Another way you can use this concept is when the property’s name is collected dynamically during the program execution, as follows: 123456789var someObj = &#123; propName: "John"&#125;;function propPrefix(str) &#123; var s = "prop"; return s + str;&#125;var someProp = propPrefix("Name"); // someProp now holds the value 'propName'console.log(someObj[someProp]); // "John" Note that we do not use quotes around the variable name when using it to access the property because we are using the value of the variable, not the name. 提示：当我们通过变量名访问属性的时候，不需要给变量名包裹引号。因为实际上我们使用的是变量的值，而不是变量的名称。 12345678var testObj = &#123; 12: &quot;Namath&quot;, 16: &quot;Montana&quot;, 19: &quot;Unitas&quot;&#125;;var playerNumber = 16; var player = testObj[playerNumber]; Updating Object PropertiesAfter you’ve created a JavaScript object, you can update its properties at any time just like you would update any other variable. You can use either dot or bracket notation to update. For example, let’s look at ourDog: 当你创建了一个对象后，你可以用点操作符或中括号操作符来更新对象的属性。 举个例子，让我们看看 ourDog: 123456var ourDog = &#123; "name": "Camper", "legs": 4, "tails": 1, "friends": ["everything!"]&#125;; Since he’s a particularly happy dog, let’s change his name to “Happy Camper”. Here’s how we update his object’s name property: 让我们更改它的名称为 “Happy Camper”，这有两种方式来更新对象的name属性： ourDog.name = &quot;Happy Camper&quot;;or 1ourDog[&quot;name&quot;] = &quot;Happy Camper&quot;; Now when we evaluate ourDog.name, instead of getting “Camper”, we’ll get his new name, “Happy Camper”. Add New Properties to a JavaScript ObjectYou can add new properties to existing JavaScript objects the same way you would modify them. Here’s how we would add a &quot;bark&quot;property to ourDog: 你也可以像更改属性一样给对象添加属性。 看看我们是如何给ourDog添加 &quot;bark&quot;属性： 1ourDog.bark = &quot;bow-wow&quot;; or 1ourDog[&quot;bark&quot;] = &quot;bow-wow&quot;; Now when we evaluate ourDog.bark, we’ll get his bark, “bow-wow”. 1234567891011121314151617181920// Examplevar ourDog = &#123; "name": "Camper", "legs": 4, "tails": 1, "friends": ["everything!"]&#125;;ourDog.bark = "bow-wow";// Setupvar myDog = &#123; "name": "Happy Coder", "legs": 4, "tails": 1, "friends": ["freeCodeCamp Campers"]&#125;;// Only change code below this line.myDog.bark = "woof"; Delete Properties from a JavaScript ObjectWe can also delete properties from objects like this: 1delete ourDog.bark; Using Objects for LookupsObjects can be thought of as a key/value storage, like a dictionary. If you have tabular data, you can use an object to “lookup” values rather than a switchstatement or an if/elsechain. This is most useful when you know that your input data is limited to a certain range. Here is an example of a simple reverse alphabet lookup: 对象和字典一样，可以用来存储键/值对。如果你的数据跟对象一样，你可以用对象来查找你想要的值，而不是使用switch或if/else语句。当你知道你的输入数据在某个范围时，这种查找方式极为有效。 这是简单的反向字母表： 123456789101112131415var alpha = &#123; 1:"Z", 2:"Y", 3:"X", 4:"W", ... 24:"C", 25:"B", 26:"A"&#125;;alpha[2]; // "Y"alpha[24]; // "C"var value = 2;alpha[value]; // "Y" 123456789101112131415161718function phoneticLookup(val) &#123; var result = ""; var lookup = &#123; alpha:"Adams", bravo:"Boston", charlie:"Chicago", delta:"Denver", echo:"Easy", foxtrot:"Frank", "":undefined&#125;; result = lookup[val]; return result;&#125;phoneticLookup("charlie"); Testing Objects for PropertiesSometimes it is useful to check if the property of a given object exists or not. We can use the .hasOwnProperty(propname)method of objects to determine if that object has the given property name. .hasOwnProperty()returns trueor falseif the property is found or not. 有时检查一个对象属性是否存在是非常有用的，我们可以用.hasOwnProperty(propname)方法来检查对象是否有该属性。如果有返回true，反之返回 false。 123456var myObj = &#123; top: "hat", bottom: "pants"&#125;;myObj.hasOwnProperty("top"); // truemyObj.hasOwnProperty("middle"); // false 12345678910111213141516171819var myObj = &#123; gift: "pony", pet: "kitten", bed: "sleigh"&#125;;function checkObj(checkProp) &#123;if (myObj.hasOwnProperty(checkProp)) &#123;return myObj[checkProp]; &#125; else &#123; return "Not Found";&#125; &#125;checkObj("gift"); Manipulating Complex ObjectsSometimes you may want to store data in a flexible Data Structure. A JavaScript object is one way to handle flexible data. They allow for arbitrary combinations of strings, numbers, booleans, arrays, functions, and objects. Here’s an example of a complex data structure: 12345678910111213var ourMusic = [ &#123; "artist": "Daft Punk", "title": "Homework", "release_year": 1997, "formats": [ "CD", "Cassette", "LP" ], "gold": true &#125;]; This is an array which contains one object inside. The object has various pieces of metadata about an album. It also has a nested &quot;formats&quot;array. If you want to add more album records, you can do this by adding records to the top level array. Objects hold data in a property, which has a key-value format. In the example above, &quot;artist&quot;: &quot;Daft Punk&quot;is a property that has a key of &quot;artist&quot;and a value of &quot;Daft Punk&quot;. JavaScript Object Notation or JSONis a related data interchange format used to store data. 1234567891011&#123; "artist": "Daft Punk", "title": "Homework", "release_year": 1997, "formats": [ "CD", "Cassette", "LP" ], "gold": true&#125; NoteYou will need to place a comma after every object in the array, unless it is the last object in the array. 1234567891011121314151617181920212223var myMusic = [ &#123; "artist": "Billy Joel", "title": "Piano Man", "release_year": 1973, "formats": [ "CS", "8T", "LP" ], "gold": true &#125;, &#123; "artist": "Tsuyoshi Hiroshi", "title": "Tonboyou", "release_year": 1987, "formats": [ "CD", "DVD", "LP"], "gold": true &#125;]; Accessing Nested Objects通过串联起来的点操作符或中括号操作符来访问JSON对象的嵌套属性。 下面是一个嵌套的JSON对象： 1234567891011121314var ourStorage = &#123; "desk": &#123; "drawer": "stapler" &#125;, "cabinet": &#123; "top drawer": &#123; "folder1": "a file", "folder2": "secrets" &#125;, "bottom drawer": "soda" &#125;&#125;;ourStorage.cabinet["top drawer"].folder2; // "secrets"ourStorage.desk.drawer; // "stapler" 12345678910111213var myStorage = &#123; "car": &#123; "inside": &#123; "glove box": "maps", "passenger seat": "crumbs" &#125;, "outside": &#123; "trunk": "jack" &#125; &#125;&#125;;var gloveBoxContents = myStorage.car.inside["glove box"]; // Change this line Accessing Nested Arrays正如我们在前面的例子所见，JSON对象可以嵌套对象和数组。与访问嵌套对象一样，用中括号操作符同样可以访问嵌套数组。 下面是如何访问嵌套数组的例子： 1234567891011121314151617181920var ourPets = [ &#123; animalType: "cat", names: [ "Meowzer", "Fluffy", "Kit-Cat" ] &#125;, &#123; animalType: "dog", names: [ "Spot", "Bowser", "Frankie" ] &#125;];ourPets[0].names[1]; // "Fluffy"ourPets[1].names[0]; // "Spot" 1234567891011121314151617181920var myPlants = [ &#123; type: "flowers", list: [ "rose", "tulip", "dandelion" ] &#125;, &#123; type: "trees", list: [ "fir", "pine", "birch" ] &#125; ];var secondTree = myPlants[1].list[1]; Record Collection右边有一个JSON对象，代表着你的专辑集。每一张专辑由一个唯一的id标识，并具有多种属性。但并非所有的专辑都有完整的信息。 写一个函数，它有个三个参数，id、prop、 value。 如果 value !=&#39;&#39; 而且prop != &#39;tracks&#39; ，collectionCopy[id][prop]=value;。 如果 value !=&#39;&#39; 而且prop == &#39;tracks&#39; ，collectionCopy[id][prop].push(value);。 如果 value == &#39;&#39; ，delete collectionCopy[id][prop];。 记住：函数返回的永远是整个对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 初始化变量var collection = &#123; 2548: &#123; album: "Slippery When Wet", artist: "Bon Jovi", tracks: [ "Let It Rock", "You Give Love a Bad Name" ] &#125;, 2468: &#123; album: "1999", artist: "Prince", tracks: [ "1999", "Little Red Corvette" ] &#125;, 1245: &#123; artist: "Robert Palmer", tracks: [ ] &#125;, 5439: &#123; album: "ABBA Gold" &#125;&#125;;// 深拷贝 collection，用于测试var collectionCopy = JSON.parse(JSON.stringify(collection));// 请只修改这条注释以下的代码function update(id, prop, value) &#123; if (collectionCopy[id].hasOwnProperty(prop) !== true)&#123; collectionCopy[id][prop] = []; &#125; if (value === "")&#123; delete collectionCopy[id][prop]; &#125; else&#123; if (prop === "tracks")&#123; collectionCopy[id].tracks.push(value); &#125; else&#123; collectionCopy[id][prop] = value; &#125; &#125; return collection;&#125;// 你可以修改这一行来测试你的代码update(5439, "artist", "ABBA"); Iterate with JavaScript While Loopsou can run the same code multiple times by using a loop. The first type of loop we will learn is called a “while“ loop because it runs “while” a specified condition is true and stops once that condition is no longer true. 123456var ourArray = [];var i = 0;while(i &lt; 5) &#123; ourArray.push(i); i++;&#125; Iterate with JavaScript For Loops一个条件语句只能执行一次代码，而一个循环语句可以多次执行代码。 JavaScript 中最常见的循环就是“for循环”。 for循环中的三个表达式用分号隔开： 1for ([初始化]; [条件判断]; [计数器]) 初始化语句只会在执行循环开始之前执行一次。它通常用于定义和设置你的循环变量。 条件判断语句会在每一轮循环的开始执行，只要条件判断为 true 就会继续执行循环。当条件为 false的时候，循环将停止执行。这意味着，如果条件在一开始就为 false，这个循环将不会执行。 计数器是在每一轮循环结束时执行，通常用于递增或递减。 在下面的例子中，先初始化i = 0，条件 i &lt; 5 为真，进入第一次循环，执行大括号里的代码，第一次循环结束。递增i的值，条件判断，就这样依次执行下去，直到条件判断为假，整个循环结束。 var ourArray = [];for (var i = 0; i &lt; 5; i++) { ourArray.push(i);} 最终 ourArray 的值为 [0,1,2,3,4]. Iterate Odd Numbers With a For Loopfor循环可以按照我们指定的顺序来迭代，通过更改我们的 计数器，我们可以按照偶数顺序来迭代。 初始化 i = 0，当 i &lt; 10 的时候继续循环。 i += 2 让 i 每次循环之后增加2。 var ourArray = [];for (var i = 0; i &lt; 10; i += 2) { ourArray.push(i);} 循环结束后，ourArray 的值为 [0,2,4,6,8]。 改变 计数器，这样我们可以用奇数来数。 12345678910111213var ourArray = [];for (var i = 0; i &lt; 10; i += 2) &#123; ourArray.push(i);&#125;var myArray = [];for (var i = 0; i &lt; 10; i++) &#123;if(i%2 == 1)&#123;myArray.push(i);&#125;&#125; Count Backwards With a For Loopfor循环也可以逆向迭代，只要我们定义好合适的条件。 为了能够从后往前两两倒数，我们需要改变我们的 初始化，条件判断 和 计数器。 我们让 i = 10，并且当 i &gt; 0 的时候才继续循环。我们使用 i-=2 来让 i 每次循环递减 2。 var ourArray = [];for (var i=10; i &gt; 0; i-=2) { ourArray.push(i);} 循环结束后，ourArray 的值为 [10,8,6,4,2]。 让我们改变 初始化 和 计数器，这样我们就可以按照奇数从后往前两两倒着数。 1234567891011var ourArray = [];for (var i = 10; i &gt; 0; i -= 2) &#123; ourArray.push(i);&#125;var myArray = [];for (var i = 9; i &gt; 0; i-=2)&#123; myArray.push(i)&#125; Iterate Through an Array with a For Loop迭代输出一个数组的每个元素是 JavaScript 中的常见需求， for 循环可以做到这一点。 下面的代码将输出数组 arr 的每个元素到控制台： 1234var arr = [10,9,8,7,6];for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; 记住数组的索引从零开始的，这意味着数组的最后一个元素的下标是：数组的长度 - 1。我们这个循环的 条件 是 i &lt; arr.length，当 i 的值为 长度-1 的时候循环就停止了。 12345678910111213var ourArr = [ 9, 10, 11, 12];var ourTotal = 0;for (var i = 0; i &lt; ourArr.length; i++) &#123; ourTotal += ourArr[i];&#125;var myArr = [ 2, 3, 4, 5, 6];var total = 0;for (var x = 0; x &lt; myArr.length; x++) &#123; total += myArr[x];&#125; Nesting For Loops如果你有一个二维数组，可以使用相同的逻辑，先遍历外面的数组，再遍历里面的子数组。下面是一个例子： 12345678var arr = [ [1,2], [3,4], [5,6]];for (var i=0; i &lt; arr.length; i++) &#123; for (var j=0; j &lt; arr[i].length; j++) &#123; console.log(arr[i][j]); &#125;&#125; 一次输出 arr 中的每个子元素。提示，对于内部循环，我们可以通过 arr[i] 的 .length 来获得子数组的长度，因为 arr[i] 的本身就是一个数组。 123456789101112131415function multiplyAll(arr) &#123; var product = 1; // Only change code below this line for(var i=0; i &lt; arr.length; i++)&#123; for (var j=0; j &lt; arr[i].length; j++)&#123; product = product * arr[i][j]; &#125; &#125; // Only change code above this line return product;&#125;// Modify values below to test your codemultiplyAll([[1,2],[3,4],[5,6,7]]); Iterate with JavaScript Do…While LoopsYou can run the same code multiple times by using a loop. The next type of loop you will learn is called a “do...while“ loop because it first will “do“ one pass of the code inside the loop no matter what, and then it runs “while“ a specified condition is true and stops once that condition is no longer true. Let’s look at an example. 123456var ourArray = [];var i = 0;do &#123; ourArray.push(i); i++;&#125; while (i &lt; 5); This behaves just as you would expect with any other type of loop, and the resulting array will look like [0, 1, 2, 3, 4]. However, what makes the do...whiledifferent from other loops is how it behaves when the condition fails on the first check. Let’s see this in action. Here is a regular while loop that will run the code in the loop as long as i &lt; 5. 123456var ourArray = []; var i = 5;while (i &lt; 5) &#123; ourArray.push(i); i++;&#125; Notice that we initialize the value of ito be 5. When we execute the next line, we notice that iis not less than 5. So we do not execute the code inside the loop. The result is that ourArraywill end up with nothing added to it, so it will still look like this []when all the code in the example above finishes running. Now, take a look at a do...whileloop. 123456var ourArray = []; var i = 5;do &#123; ourArray.push(i); i++;&#125; while (i &lt; 5); In this case, we initialize the value of ias 5, just like we did with the while loop. When we get to the next line, there is no check for the value of i, so we go to the code inside the curly braces and execute it. We will add one element to the array and increment ibefore we get to the condition check. Then, when we get to checking if i &lt; 5see that iis now 6, which fails the conditional check. So we exit the loop and are done. At the end of the above example, the value of ourArrayis [5]. Essentially, a do...whileloop ensures that the code inside the loop will run at least once. Let’s try getting a do...whileloop to work by pushing values to an array. Change the whileloop in the code to a do...whileloop so that the loop will push the number 10 to myArray, and iwill be equal to 11when your code finishes running. 12345678910111213// Setupvar myArray = [];var i = 10;do &#123; myArray.push(i); i++;&#125; while (i &lt; 5)// Only change code below this line.while (i &lt; 5) &#123; myArray.push(i); i++;&#125; Profile Lookup我们有一个对象数组，里面存储着通讯录。 函数 lookUp 有两个预定义参数：firstName值和prop属性 。 函数将会检查通讯录中是否存在一个与传入的 firstName 相同的联系人。如果存在，那么还需要检查对应的联系人中是否存在 prop属性。 如果它们都存在，函数返回prop属性对应的值。 如果firstName 值不存在，返回 &quot;No such contact&quot;。 如果prop 属性不存在，返回 &quot;No such property&quot;。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var contacts = [ &#123; "firstName": "Akira", "lastName": "Laine", "number": "0543236543", "likes": ["Pizza", "Coding", "Brownie Points"] &#125;, &#123; "firstName": "Harry", "lastName": "Potter", "number": "0994372684", "likes": ["Hogwarts", "Magic", "Hagrid"] &#125;, &#123; "firstName": "Sherlock", "lastName": "Holmes", "number": "0487345643", "likes": ["Intriguing Cases", "Violin"] &#125;, &#123; "firstName": "Kristian", "lastName": "Vos", "number": "unknown", "likes": ["JavaScript", "Gaming", "Foxes"] &#125;];function lookUpProfile(firstName, prop)&#123;// Only change code below this line for( var i = 0; i &lt; contacts.length; i++ )&#123; if( firstName == contacts[i].firstName ) &#123; if( contacts[i].hasOwnProperty( prop ) ) &#123; return contacts[i][prop]; &#125; else &#123; return "No such property"; &#125; &#125; &#125; return "No such contact";// Only change code above this line&#125;// Change these values to test your functionlookUpProfile("Akira", "likes"); Generate Random Fractions with JavaScript计算机的行为只有两种：确定性和随机性。当你一步步地闯关来到这里就是确定行为，当你随意点了个链接就来到这里就是随机行为。 而随机数最适合用来创建这种随机行为。 Math.random()用来生成一个在0(包括0)到1(不包括1)之间的随机小数，因此Math.random()可能返回0但绝不会返回1。 提示随后的函数都会在return执行前调用，所以我们可以直接返回Math.random()的值。 1234567891011121314function randomFraction() &#123; // Only change code below this line. var result = 0; while (result === 0) &#123; result = Math.random(); &#125; return result; // Only change code above this line.&#125; Generate Random Whole Numbers with JavaScript生成随机小数很棒，但随机数更有用的地方在于生成随机整数。 用 Math.random() 生成一个随机小数。 把这个随机小数乘以 20。 用 Math.floor() 向下取整 获得它最近的整数。 记住 Math.random() 永远不会返回 1。同时因为我们是在用 Math.floor() 向下取整，所以最终我们获得的结果不可能有 20。这确保了我们获得了一个在0到19之间的整数。 把操作连缀起来，代码类似于下面： 1Math.floor(Math.random() * 20); 我们先调用 Math.random()，把它的结果乘以20，然后把上一步的结果传给 Math.floor()，最终通过向下取整获得最近的整数。 任务生成一个 0 到 9之间的随机整数。 12345678var randomNumberBetween0and19 = Math.floor(Math.random() * 20);function randomWholeNum() &#123; // Only change code below this line. return Math.floor(Math.random() * 10);&#125; Generate Random Whole Numbers within a Range我们之前生成的随机数是在0到某个数之间，现在我们要生成的随机数是在两个指定的数之间。 我们需要定义一个最小值和一个最大值。 下面是我们将要使用的方法，仔细看看并尝试理解这行代码到底在干嘛： 1Math.floor(Math.random() * (max - min + 1)) + min 任务创建一个叫randomRange的函数，参数为myMin和myMax，返回一个在myMin(包括myMin)和myMax(包括myMax)之间的随机数。 123456789101112131415161718192021function ourRandomRange(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourRandomRange(1, 9);// Only change code below this line.function randomRange(myMin, myMax) &#123; return Math.floor(Math.random() * (myMax - myMin + 1)) + myMin;&#125;var myRandom = randomRange(5, 15);console.log(myRandom);// Change these values to test your functionvar myRandom = randomRange(5, 15); Use the parseInt FunctionThe parseInt()function parses a string and returns an integer. Here’s an example: 1var a = parseInt(&quot;007&quot;); The above function converts the string “007” to an integer 7. If the first character in the string can’t be converted into a number, then it returns NaN. Use parseInt()in the convertToIntegerfunction so it converts the input string strinto an integer, and returns it. 12345function convertToInteger(str)&#123; return parseInt(str);&#125;convertToInteger("56"); Use the parseInt Function with a RadixThe parseInt()function parses a string and returns an integer. It takes a second argument for the radix, which specifies the base of the number in the string. The radix can be an integer between 2 and 36. The function call looks like: 1parseInt(string, radix); And here’s an example: 1var a = parseInt("11", 2); The radix variable says that “11” is in the binary system, or base 2. This example converts the string “11” to an integer 3. Use parseInt()in the convertToIntegerfunction so it converts a binary number to an integer and returns it. 123456function convertToInteger(str) &#123;var radix = 2;return parseInt(str, radix);&#125;convertToInteger("10011"); Use the Conditional (Ternary) OperatorThe conditional operator, also called the ternary operator, can be used as a one line if-else expression. The syntax is: 1condition ? statement-if-true : statement-if-false; The following function uses an if-else statement to check a condition: 12345678function findGreater(a, b) &#123; if(a &gt; b) &#123; return "a is greater"; &#125; else &#123; return "b is greater"; &#125;&#125; This can be re-written using the conditional operator: 123function findGreater(a, b) &#123; return a &gt; b ? "a is greater" : "b is greater";&#125; 练习： Use the conditional operatorin the checkEqualfunction to check if two numbers are equal or not. The function should return either true or false. 12345function checkEqual(a, b) &#123; return (a == b ? true : false );&#125;checkEqual(1, 2); Use Multiple Conditional (Ternary) OperatorsIn the previous challenge, you used a single conditional operator. You can also chain them together to check for multiple conditions. The following function uses if, else if, and else statements to check multiple conditions: 1234567891011function findGreaterOrEqual(a, b) &#123; if(a === b) &#123; return "a and b are equal"; &#125; else if(a &gt; b) &#123; return "a is greater"; &#125; else &#123; return "b is greater"; &#125;&#125; The above function can be re-written using multiple conditional operators: 123function findGreaterOrEqual(a, b) &#123; return (a === b) ? "a and b are equal" : (a &gt; b) ? "a is greater" : "b is greater";&#125; 练习： Use multiple conditional operatorsin the checkSignfunction to check if a number is positive, negative or zero. 12345function checkSign(num) &#123; return (num &gt; 0) ? 'positive' : (num &lt; 0) ? 'negative' : 'zero';&#125;checkSign(10);]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 pandas 第1章 Series对象]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-pandas-%E7%AC%AC1%E7%AB%A0-Series%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook Pandas 有三个基本数据结构：Series、DataFrame 和 Index。 NumPy 数组通过隐式定义的整数索引获取数值， 而 Pandas 的 Series 对象用一种显式定义的索引与数值关联。 导入12import numpy as npimport pandas as pd Series对象12345678data = pd.Series([0.25, 0.5, 0.75, 1.0], index=['a', 'b', 'c', 'd'])dataa 0.25b 0.50c 0.75d 1.00dtype: float64 123data.values&gt;&gt;&gt; array([ 0.25, 0.5 , 0.75, 1. ]) 123data.index&gt;&gt;&gt; RangeIndex(start=0, stop=4, step=1) 12345data[1:3]&gt;&gt;&gt; 1 0.50 2 0.75 dtype: float64 123data['b']&gt;&gt;&gt; 0.5 123'a' in data&gt;&gt;&gt; True 123data.keys()&gt;&gt;&gt; Index(['a', 'b', 'c', 'd'], dtype='object') 123list(data.items())&gt;&gt;&gt; [('a', 0.25), ('b', 0.5), ('c', 0.75), ('d', 1.0)] 123456789data['e'] = 1.25dataa 0.25b 0.50c 0.75d 1.00e 1.25dtype: float64 字典1234567891011121314population_dict = &#123;'California': 38332521, 'Texas': 26448193, 'New York': 19651127, 'Florida': 19552860, 'Illinois': 12882135&#125;population = pd.Series(population_dict)populationCalifornia 38332521Florida 19552860Illinois 12882135New York 19651127Texas 26448193dtype: int64 123population['California']&gt;&gt;&gt; 38332521 123456population['California':'Illinois']&gt;&gt;&gt; California 38332521 Florida 19552860 Illinois 12882135 dtype: int64 显式指定索引123456pd.Series([2, 4, 6])&gt;&gt;&gt; 0 2 1 4 2 6 dtype: int64 12345pd.Series(&#123;2:'a', 1:'b', 3:'c'&#125;, index=[3, 2])&gt;&gt;&gt; 3 c 2 a dtype: object]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[U盘容量变小解决方法]]></title>
    <url>%2F2019%2F06%2F07%2FU%E7%9B%98%E5%AE%B9%E9%87%8F%E5%8F%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[之前U盘用来装镜像ISO了，很久没用，突然发现容量只有3M多… 比较麻烦的解决方法清除磁盘打开命令提示符窗口，输入list disk，找到自己的U盘 磁盘2就是我的U盘。 接下来输入select disk 2，显示磁盘2现在是所选磁盘。 然后输入clean 添加卷win10系统，右键此电脑，点击管理，跳转到计算机管理窗口。 储存——&gt;磁盘管理 ——&gt; 找到自己的U盘，如果是黑色条的话，右键黑色条，选择新建简单卷 一直点击下一步直到确定。 成功的话，颜色就变成深蓝色，提示状态良好。 查看下U盘的容量，就变正常了。 比较快的解决方法下载工具（优启通），点击归还空间]]></content>
  </entry>
  <entry>
    <title><![CDATA[python编程 从入门到实践 9.3 TypeError]]></title>
    <url>%2F2019%2F06%2F07%2Fpython%E7%BC%96%E7%A8%8B-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5-9-3-TypeError%2F</url>
    <content type="text"><![CDATA[TypeError1234567891011121314151617181920212223242526272829class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): print("This car has " + str(self.odometer_reading) + " miles on it.") def update_odometer(self, mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print("You can't roll back an odometer!") def increment_odometer(self, miles): self.odometer_reading += miles class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year)my_tesla = ElectricCar('tesla', 'model s', 2016)print(my_tesla.get_descriptive_name()) 直接在sublime text运行会出现错误： 123456Traceback (most recent call last): File "D:\python_work\electric_car.py", line 28, in &lt;module&gt; my_tesla = ElectricCar('tesla', 'model s', 2016) File "D:\python_work\electric_car.py", line 26, in __init__ super().__init__(make, model, year)TypeError: super() takes at least 1 argument (0 given) 因为sublime text默认是Python2，所以我的vs code和pycharm都不会出现这个问题。 既然其他编辑器能正常运行，问题就只是出在sublime text上，那修改方法如下： 第1种安装https://packagecontrol.io/packages/Python%203的python3： 注意这个的版本是2017年的。 具体步骤 先安装 Package Control 打开 Tools → Command Palette 选择 Package Control: Install Package 搜索Python 3 和 Cython+ ，找到并安装 修改View → Syntax → Open all with current extension as… →为 Python 3 如何安装Package Control如果你没有安装过Package Control： 点击 Preferences &gt; Browse Packages… menu Browse up a folder and then into the Installed Packages/ folder 下载 Package Control.sublime-package 然后复制到 Installed Packages/ 目录 重启 Sublime Text 第2种（推荐）找到电脑里的python路径： 配置sublime text里运行python的环境： 打开 Tools → Build System→ New Build System... 12345&#123; "cmd": ["C:/Users/dell/AppData/Local/Programs/Python/Python36/Python.exe", "-u", "$file"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python"&#125; 另存为Python3.6.8.sublime-build，然后在修改Tool → Build System →为 python 3.6.8]]></content>
  </entry>
  <entry>
    <title><![CDATA[python PEP263]]></title>
    <url>%2F2019%2F06%2F07%2Fpython-PEP263%2F</url>
    <content type="text"><![CDATA[https://www.python.org/dev/peps/pep-0263/ SyntaxError Non-ASCII character ‘\xe5’ in file D:\python_work\electric_car_1.py on line 23, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 本来可以正常run的py文件突然这样提示error，去官网看下解决方法。 原因 In Python 2.1, Unicode literals can only be written using the Latin-1 based encoding “unicode-escape”. This makes the programming environment rather unfriendly to Python users who live and work in non-Latin-1 locales such as many of the Asian countries. Programmers can write their 8-bit strings using the favorite encoding, but are bound to the “unicode-escape” encoding for Unicode literals. 在Python 2.1中，Unicode文字只能使用基于Latin-1的编码“unicode-escape”编写。这使得编程环境对在非拉丁语1语言环境中生活和工作的Python用户非常不友好，例如许多亚洲国家。程序员可以使用喜欢的编码来编写他们的8位字符串，但是绑定到Unicode文字的“unicode-escape”编码。 解决方法 I propose to make the Python source code encoding both visible and changeable on a per-source file basis by using a special comment at the top of the file to declare the encoding. 我建议在每个源文件的基础上使Python源代码编码可见和可更改，方法是使用文件顶部的特殊注释来声明编码。 Python will default to ASCII as standard encoding if no other encoding hints are given. 如果没有给出其他编码提示，Python将默认为ASCII作为标准编码。 在py文件开头加上： 12#!/usr/bin/python# -*- coding: UTF-8 -*-]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python naming conflict]]></title>
    <url>%2F2019%2F05%2F30%2FPython-naming-conflict%2F</url>
    <content type="text"><![CDATA[案例群里小伙伴说pycharm可以正常run代码，debug有错误提示。 DebugAttributeError：module ‘numbers’ has no attribute ‘Number’ 解决方法原因是Naming conflict，有个叫numbers.py的文件与python的standard library里的numbers命名冲突，把numbers.py文件重命名或者删掉它，pycharm debug就不会有traceback了。 类似的问题我看到类似的问题还有，AttributeError: module &#39;random&#39; has no attribute &#39;randint&#39;。 那要记得命名时不要命名为random.py。 注意py文件命名时，不要和python内建函数、standard library重名。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Anaconda下载慢]]></title>
    <url>%2F2019%2F05%2F30%2FAnaconda%E4%B8%8B%E8%BD%BD%E6%85%A2%2F</url>
    <content type="text"><![CDATA[Anaconda下载慢为了录视频，想演示下anaconda安装使用，所以卸载了打算重新安装。没想到下载了半天都下载不下来，刚好这个月清华镜像也不能用。反正很多库暂时用不到，所以先把录视频所需的几样东西安装好了就行了… 重新下载安装需要的东西： python （在官网下载） numpy （cmd输入pip install numpy） pandas （cmd输入pip install pandas） matplotlib （cmd输入pip install matplotlib） jupyter notebook （cmd输入pip install jupyter） Jupyter notebook https://jupyter.org/install.html error安装了之后我输入jupyter，报错： 1jupyter: error: one of the arguments --version subcommand --config-dir --data-dir --runtime-dir --paths is required 解决方法：cmd输入 1jupyter notebook 就能打开本地http://localhost:8888/tree，浏览器会自动弹出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[matplotlib c argument]]></title>
    <url>%2F2019%2F05%2F30%2Fmatplotlib-c-argument%2F</url>
    <content type="text"><![CDATA[1plt.scatter(x_values, y_values, c=(0, 0, 0.8), edgecolor='none', s=40) Warn ‘c’ argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with ‘x’ &amp; ‘y’. Please use a 2-D array with a single row if you really want to specify the same RGB or RGBA value for all points. Answer from stackoverflow In the latest version of matplotlib (3.0.3), argument ‘c’ should be a 2-D array. If the length of ‘c’ matches with the length of ‘x’ and ‘y’, the color of each point corresponds to the element of the ‘c’. If you want to make every point show the same color, ‘c’ should be a 2-D array with a single row, such as c=np.array([0.5, 0.5, 0.5]). https://stackoverflow.com/questions/55109716/c-argument-looks-like-a-single-numeric-rgb-or-rgba-sequence 原因是新的matplotlib版本里，argument c 应该是2维数组。 我试过改成c=np.array([0, 0, 0.8])，还是不行。 最终解决方法为： 把 ’c‘ argument 改成 color。 1plt.scatter(x_values, y_values, color=(0, 0, 0.8), edgecolor='none', s=40)]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy 100题练习 Day5]]></title>
    <url>%2F2019%2F05%2F24%2Fnumpy-100%E9%A2%98%E7%BB%83%E4%B9%A0-Day5%2F</url>
    <content type="text"><![CDATA[https://github.com/rougier/numpy-100 How to sum a small array faster than np.sum?1234# Author: Evgeni BurovskiZ = np.arange(10)np.add.reduce(Z) Consider two random array A and B, check if they are equal12345678910A = np.random.randint(0,2,5)B = np.random.randint(0,2,5)# Assuming identical shape of the arrays and a tolerance for the comparison of valuesequal = np.allclose(A,B)print(equal)# Checking both the shape and the element values, no tolerance (values have to be exactly equal)equal = np.array_equal(A,B)print(equal) Make an array immutable (read-only)123Z = np.zeros(10)Z.flags.writeable = FalseZ[0] = 1 Consider a random 10x2 matrix representing cartesian coordinates, convert them to polar coordinates123456Z = np.random.random((10,2))X,Y = Z[:,0], Z[:,1]R = np.sqrt(X**2+Y**2)T = np.arctan2(Y,X)print(R)print(T) Create random vector of size 10 and replace the maximum value by 0123Z = np.random.random(10)Z[Z.argmax()] = 0print(Z) Create a structured array with x and y coordinates covering the [0,1]x[0,1] area1234Z = np.zeros((5,5), [('x',float),('y',float)])Z['x'], Z['y'] = np.meshgrid(np.linspace(0,1,5), np.linspace(0,1,5))print(Z) Given two arrays, X and Y, construct the Cauchy matrix C (Cij =1/(xi - yj))123456# Author: Evgeni BurovskiX = np.arange(8)Y = X + 0.5C = 1.0 / np.subtract.outer(X, Y)print(np.linalg.det(C)) Print the minimum and maximum representable value for each numpy scalar type1234567for dtype in [np.int8, np.int32, np.int64]: print(np.iinfo(dtype).min) print(np.iinfo(dtype).max)for dtype in [np.float32, np.float64]: print(np.finfo(dtype).min) print(np.finfo(dtype).max) print(np.finfo(dtype).eps) How to print all the values of an array?123np.set_printoptions(threshold=np.nan)Z = np.zeros((16,16))print(Z) How to find the closest value (to a given scalar) in a vector?1234Z = np.arange(100)v = np.random.uniform(0,100)index = (np.abs(Z-v)).argmin()print(Z[index])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy 100题练习 Day4]]></title>
    <url>%2F2019%2F05%2F24%2Fnumpy-100%E9%A2%98%E7%BB%83%E4%B9%A0-Day4%2F</url>
    <content type="text"><![CDATA[https://github.com/rougier/numpy-100 How to ignore all numpy warnings (not recommended)?123456# Suicide mode ondefaults = np.seterr(all="ignore")Z = np.ones(1) / 0# Back to sanity_ = np.seterr(**defaults) An equivalent way, with a context manager: 12with np.errstate(divide='ignore'): Z = np.ones(1) / 0 Is the following expressions true?1np.sqrt(-1) == np.emath.sqrt(-1) How to get the dates of yesterday, today and tomorrow?123yesterday = np.datetime64('today', 'D') - np.timedelta64(1, 'D')today = np.datetime64('today', 'D')tomorrow = np.datetime64('today', 'D') + np.timedelta64(1, 'D') How to get all the dates corresponding to the month of July 2016?12Z = np.arange('2016-07', '2016-08', dtype='datetime64[D]')print(Z) How to compute ((A+B)*(-A/2)) in place (without copy)?1234567A = np.ones(3)*1B = np.ones(3)*2C = np.ones(3)*3np.add(A,B,out=B)np.divide(A,2,out=A)np.negative(A,out=A)np.multiply(A,B,out=A) Extract the integer part of a random array using 5 different methods1234567Z = np.random.uniform(0,10,10)print (Z - Z%1)print (np.floor(Z))print (np.ceil(Z)-1)print (Z.astype(int))print (np.trunc(Z)) Create a 5x5 matrix with row values ranging from 0 to 4123Z = np.zeros((5,5))Z += np.arange(5)print(Z) Consider a generator function that generates 10 integers and use it to build an array12345def generate(): for x in range(10): yield xZ = np.fromiter(generate(),dtype=float,count=-1)print(Z) Create a vector of size 10 with values ranging from 0 to 1, both excluded12Z = np.linspace(0,1,11,endpoint=False)[1:]print(Z) Create a random vector of size 10 and sort it123Z = np.random.random(10)Z.sort()print(Z)]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy 100题练习 Day3]]></title>
    <url>%2F2019%2F05%2F24%2Fnumpy-100%E9%A2%98%E7%BB%83%E4%B9%A0-Day3%2F</url>
    <content type="text"><![CDATA[https://github.com/rougier/numpy-100 Create a checkerboard 8x8 matrix using the tile function1234567891011Z = np.tile( np.array([[0,1],[1,0]]), (4,4))print(Z)[[0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0]] numpy.tile https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html Construct an array by repeating A the number of times given by reps. If reps has length d, the result will have dimension of max(d, A.ndim). If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote A to d-dimensions manually before calling this function. If A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1’s to it. Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as (1, 1, 2, 2). 参数 A （the input array） reps （the number of repetitions of a long each axis） 例子1234567891011&gt;&gt;&gt; a = np.array([0, 1, 2])&gt;&gt;&gt; np.tile(a, 2)array([0, 1, 2, 0, 1, 2])&gt;&gt;&gt; np.tile(a, (2, 2))array([[0, 1, 2, 0, 1, 2], [0, 1, 2, 0, 1, 2]]) &gt;&gt;&gt; np.tile(a, (2, 1, 2))array([[[0, 1, 2, 0, 1, 2]], [[0, 1, 2, 0, 1, 2]]]) Normalize a 5x5 random matrix123456789Z = np.random.random((5,5))Z = (Z - np.mean (Z)) / (np.std (Z))print(Z)[[-1.500019 1.11585252 -0.47634185 -0.82878742 0.83100145] [-0.60877327 0.80508094 1.01055956 0.8768261 -1.14530307] [-1.42879691 0.42025043 1.33401344 -0.16557947 -0.25317782] [-1.15284007 -0.71064254 -0.33070097 -1.340814 1.22239397] [ 0.29678951 1.15295262 1.34864726 -1.48277079 1.01017939]] Create a custom dtype that describes a color as four unsigned bytes (RGBA)1234color = np.dtype([("r", np.ubyte, 1), ("g", np.ubyte, 1), ("b", np.ubyte, 1), ("a", np.ubyte, 1)]) Multiply a 5x3 matrix by a 3x2 matrix (real matrix product)123456789101112Z = np.dot(np.ones((5,3)), np.ones((3,2)))print(Z)# Alternative solution, in Python 3.5 and aboveZ = np.ones((5,3)) @ np.ones((3,2))print(Z)[[3. 3.] [3. 3.] [3. 3.] [3. 3.] [3. 3.]] numpy.dotDot product of two arrays. Specifically, If both a and b are 1-D arrays, it is inner product of vectors (without complex conjugation). If both a and b are 2-D arrays, it is matrix multiplication, but using matmul or a @ b is preferred. If either a or b is 0-D (scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a * b is preferred. If a is an N-D array and b is a 1-D array, it is a sum product over the last axis of a and b. If a is an N-D array and b is an M-D array (where M&gt;=2), it is a sum product over the last axis of a and the second-to-last axis of b: 1dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m]) 参数 a b out 例子12345678&gt;&gt;&gt; np.dot(3, 4)12&gt;&gt;&gt; a = [[1, 0], [0, 1]]&gt;&gt;&gt; b = [[4, 1], [2, 2]]&gt;&gt;&gt; np.dot(a, b)array([[4, 1], [2, 2]]) Given a 1D array, negate all elements which are between 3 and 8, in place.1234567# Author: Evgeni BurovskiZ = np.arange(11)Z[(3 &lt; Z) &amp; (Z &lt;= 8)] *= -1print(Z)&gt;&gt;&gt; [ 0 1 2 3 -4 -5 -6 -7 -8 9 10] What is the output of the following script?12345678# Author: Jake VanderPlasprint(sum(range(5),-1))from numpy import *print(sum(range(5),-1))&gt;&gt;&gt; 9&gt;&gt;&gt; 10 Consider an integer vector Z, which of these expressions are legal?123456Z**Z2 &lt;&lt; Z &gt;&gt; 2Z &lt;- Z1j*ZZ/1/1Z&lt;Z&gt;Z What are the result of the following expressions?1234567print(np.array(0) / np.array(0))print(np.array(0) // np.array(0))print(np.array([np.nan]).astype(int).astype(float))&gt;&gt;&gt; nan&gt;&gt;&gt; 0&gt;&gt;&gt; [-9.22337204e+18] How to round away from zero a float array ?123456# Author: Charles R HarrisZ = np.random.uniform(-10,+10,10)print (np.copysign(np.ceil(np.abs(Z)), Z))&gt;&gt;&gt; [ -3. -5. -9. -6. 2. 2. -1. 10. -6. -10.] How to find common values between two arrays?12345Z1 = np.random.randint(0,10,10)Z2 = np.random.randint(0,10,10)print(np.intersect1d(Z1,Z2))&gt;&gt;&gt; [1 2 4 6 8] https://docs.scipy.org/doc/numpy/reference/generated/numpy.intersect1d.html numpy.intersect1dFind the intersection of two arrays. Return the sorted, unique values that are in both of the input arrays. 123&gt;&gt;&gt; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])&gt;&gt;&gt; array([1, 3])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy 100题练习 Day2]]></title>
    <url>%2F2019%2F05%2F24%2Fnumpy-100%E9%A2%98%E7%BB%83%E4%B9%A0-Day2%2F</url>
    <content type="text"><![CDATA[https://github.com/rougier/numpy-100 Create a 3x3 identity matrix创建一个3x3的矩阵，返回一个对角线是1，其余是0的数组。 np.eye(N)，N行。 123456Z = np.eye(3)print(Z)&gt;&gt;&gt; [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] Create a 3x3x3 array with random values创建一个用随机数组成的3x3x3数组。 1234567891011121314Z = np.random.random((3,3,3))print(Z)&gt;&gt;&gt; [[[0.11085346 0.63675724 0.56551715] [0.85845655 0.83132722 0.15546257] [0.68620584 0.9561824 0.59587874]] [[0.49882408 0.56935352 0.9964925 ] [0.81017846 0.83963088 0.77471192] [0.59353945 0.73767187 0.6880103 ]] [[0.4130483 0.55252658 0.88652063] [0.45995876 0.66758083 0.57286753] [0.34854386 0.09369495 0.90712067]]] Create a 10x10 array with random values and find the minimum and maximum values创建一个10x10的随机数组，并且找到最小值和最大值。 12345Z = np.random.random((10,10))Zmin, Zmax = Z.min(), Z.max()print(Zmin, Zmax)&gt;&gt;&gt; 0.0009066852233082789 0.9990012244445428 Create a random vector of size 30 and find the mean value创建一个大小为30的随机矢量，并且找到平均值。 np.mean 计算元素的平均值。 12345Z = np.random.random(30)m = Z.mean()print(m)&gt;&gt;&gt; 0.4892178091799963 Create a 2d array with 1 on the border and 0 inside创建一个2维数组，并且边框都为数值1，内部数组都为0。 运用切片，[start:stop:step]。 123Z = np.ones((10,10))Z[1:-1,1:-1] = 0print(Z) 1234567891011# output[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] How to add a border (filled with 0’s) around an existing array?如何在当前数组添加一个用数值0填充的边框？ 123Z = np.ones((5,5))Z = np.pad(Z, pad_width=1, mode='constant', constant_values=0)print(Z) 12345678# output[[0. 0. 0. 0. 0. 0. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 1. 1. 1. 1. 1. 0.] [0. 0. 0. 0. 0. 0. 0.]] Numpy.pad() https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html 填充数组。 参数： rank N 填充的数组 pad_width 填充的数值 mode 有11种填充模式，constant表示连续填充相同的值。constant_values = (x,y) stat_length constant_values end_values reflect_type What is the result of the following expression?12345678910111213print(0 * np.nan)print(np.nan == np.nan)print(np.inf &gt; np.nan)print(np.nan - np.nan)print(np.nan in set([np.nan]))print(0.3 == 3 * 0.1)nanFalseFalsenanTrueFalse IEEE 754 floating point representation of Not a Number (NaN). Create a 5x5 matrix with values 1,2,3,4 just below the diagonal创建一个在对角线下方的值为1，2，3，4 的 5x5矩阵。 12345678Z = np.diag(1+np.arange(4),k=-1)print(Z)[[0 0 0 0 0] [1 0 0 0 0] [0 2 0 0 0] [0 0 3 0 0] [0 0 0 4 0]] http://www.numpy.org/devdocs/reference/generated/numpy.diag.html Create a 8x8 matrix and fill it with a checkerboard pattern创建一个内部填充棋盘图案的8x8矩阵。 12345678910111213Z = np.zeros((8,8),dtype=int)Z[1::2,::2] = 1Z[::2,1::2] = 1print(Z)[[0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0]] Consider a (6,7,8) shape array, what is the index (x,y,z) of the 100th element?在一个形状为（6，7，8）的数组里，第100个元素的索引（x，y，z）的数值是？ 123print(np.unravel_index(99,(6,7,8)))&gt;&gt;&gt; (1, 5, 4) https://docs.scipy.org/doc/numpy/reference/generated/numpy.unravel_index.html]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy 100题练习 Day1]]></title>
    <url>%2F2019%2F05%2F24%2Fnumpy-100%E9%A2%98%E7%BB%83%E4%B9%A0-Day1%2F</url>
    <content type="text"><![CDATA[https://github.com/rougier/numpy-100 Import the numpy package under the name np使用import语句导入numpy，别名为np。 1import numpy as np Print the numpy version and the configuration查看numpy的版本和设置。 1234print(np.__version__)np.show_config()# 记得要先运行导入numpy代码，才能运行这个 Create a null vector of size 10创建一个大小为10，全是浮点数0的矢量 1234Z = np.zeros(10)print(Z)&gt;&gt;&gt; [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] How to find the memory size of any array数组总字节大小的属性 = 数组的总大小size * 每个数组元素字节的大小itemsize 1234Z = np.zeros((10,10))print("%d bytes" % (Z.size * Z.itemsize))&gt;&gt;&gt; 800 bytes How to get the documentation of the numpy add function from the command line?如何在cmd得到numpy.add函数的文档？ 1python -c "import numpy; numpy.info(numpy.add)" Create a null vector of size 10 but the fifth value which is 1创建10个浮点数值为0的矢量，改变索引5的值，改成1。 12345Z = np.zeros(10)Z[4] = 1print(Z)&gt;&gt;&gt; [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] Create a vector with values ranging from 10 to 49创建一个矢量，生成start = 10, stop = 50的等间隔数值，默认间隔为1。 12345Z = np.arange(10,50)print(Z)&gt;&gt;&gt; [10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49] Reverse a vector (first element becomes last)创建一个矢量，生成start = 10, stop = 50的等间隔数值，默认间隔为1。并且所有元素逆序。 1234567Z = np.arange(50)Z = Z[::-1]print(Z)&gt;&gt;&gt; [49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0] Create a 3x3 matrix with values ranging from 0 to 8创建一个矩阵，生成start = 0, stop = 9 的等间隔数值，默认间隔为1。3行3列。 1234Z = np.arange(9).reshape(3,3)print(Z)&gt;&gt;&gt;[[0 1 2][3 4 5][6 7 8]] Find indices of non-zero elements from [1,2,0,0,4,0]从[1,2,0,0,4,0]中查找非0元素。 np.nonzero()返回非0元素的位置，数组中索引0、1、4的位置分别为1、2、4。 1234nz = np.nonzero([1,2,0,0,4,0])print(nz)&gt;&gt;&gt; (array([0, 1, 4]),)]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第7章 花式索引]]></title>
    <url>%2F2019%2F05%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC7%E7%AB%A0-%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook https://www.numpy.org.cn Fancy indexing作用-获取数组中特定元素快速获得并修改复杂的数组值得子数据集。 传递的是索引数组，而不是单个标量。 单个维度1234567891011import numpy as nprand = np.random.RandomState(42)x = rand.randint(100, size=10)print(x)&gt;&gt;&gt; [51 92 14 71 60 20 82 86 74 74][x[3], x[7], x[2]]&gt;&gt;&gt; [71, 86, 14] 123456# 传递索引的单个列表或数组ind = [3, 7, 4]x[ind]&gt;&gt;&gt; array([71, 86, 60]) 12345678# 利用花哨的索引，结果的形状与索引数组的形状一致，而不是与被索引数组的形状一致ind = np.array([[3, 7], [4, 5]])x[ind]&gt;&gt;&gt; array([[71, 86], [60, 20]]) 多维度123456789101112X = np.arange(12).reshape((3, 4))X&gt;&gt;&gt; array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) row = np.array([0, 1, 2])col = np.array([2, 1, 3])X[row, col]&gt;&gt;&gt; array([ 2, 5, 11])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第5章 广播]]></title>
    <url>%2F2019%2F05%2F24%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC5%E7%AB%A0-%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html https://github.com/jakevdp/PythonDataScienceHandbook 广播 Broadcasting执行算术运算时使用不同形状的数组 广播规则 如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1。 如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状。 如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于 1，那么会引发异常。 例子12345import numpy as npx1 = np.arange(3) + 5x1&gt;&gt;&gt; array([5, 6, 7]) 123456x2 = np.ones((3,3)) + np.arange(3)x2&gt;&gt;&gt; array([[1., 2., 3.], [1., 2., 3.], [1., 2., 3.]]) 123456x3 = np.ones((3,1)) + np.arange(3)x3&gt;&gt;&gt; array([[1., 2., 3.], [1., 2., 3.], [1., 2., 3.]]) 12345678910111213141516171819202122# 2维数组和1维数组相加M = np.ones((2, 3), dtype =int)a = np.arange(3)a&gt;&gt;&gt; array([0, 1, 2])# 数组 a 的维度数更小，所以在其左边补 1：# M.shape -&gt; (2, 3)# a.shape -&gt; (1, 3)# 补了1之后：# M.shape -&gt; (2, 3)# a.shape -&gt; (2, 3)(M + a).shape&gt;&gt;&gt; (2, 3)M + a&gt;&gt;&gt; array([[1, 2, 3], [1, 2, 3]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第3章 聚合函数]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC3%E7%AB%A0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数名称 NaN安全版本 描述 np.sum np.nansum 计算元素的和 np.prod np.nanprod 计算元素的积 np.mean np.nanmean 计算元素的平均值 np.std np.nanstd 计算元素的标准差 np.var np.nanvar 计算元素的方差 np.min np.nanmin 找出最小值 np.max np.nanmax 找出最大值 np.argmin np.nanargmin 找出最小值的索引 np.argmax np.nanargmax 找出最大值的索引 np.median np.nanmedian 计算元素的中位数 np.percentile np.nanpercentile 计算基于元素排序的统计值 np.any N/A 验证是否存在元素为真 np.all N/A 验证所有元素是否为真 numpy.sum12345&gt;&gt;&gt; np.sum([0.5, 1.5])&gt;&gt;&gt; 2.0&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])&gt;&gt;&gt; 6 numpy.prod12345678&gt;&gt;&gt; np.prod([1.,2.])&gt;&gt;&gt; 2.0&gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]])&gt;&gt;&gt; 24.0&gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]], axis=1)&gt;&gt;&gt; array([ 2., 12.]) numpy.mean123456&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])&gt;&gt;&gt; np.mean(a)&gt;&gt;&gt; 2.5&gt;&gt;&gt; np.mean(a, axis=1)&gt;&gt;&gt; array([ 1.5, 3.5]) https://github.com/jakevdp/PythonDataScienceHandbook https://docs.scipy.org/doc/]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第3章 算术运算符]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC3%E7%AB%A0-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[运算符 对应的通用函数 描述 + np.add 加法运算（即 1 + 1 = 2） - np.subtract 减法运算（即 3 - 2 = 1） - np.negative 负数运算（ 即 -2） * np.multiply 乘法运算（即 2 \* 3 = 6） / np.divide 除法运算（即 3 / 2 = 1.5） // np.floor_divide 向下整除运算（floor division，即 3 // 2 = 1） ** np.power 指数运算（即 2 ** 3 = 8） % np.mod 模 / 余数（ 即 9 % 4 = 1） https://github.com/jakevdp/PythonDataScienceHandbook https://docs.scipy.org/doc/]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第2章 数组分裂]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E7%BB%84%E5%88%86%E8%A3%82%2F</url>
    <content type="text"><![CDATA[np.splitSplit an array into multiple sub-arrays 向以上函数传递一个索引列表作为参数，索引列表记录的是分裂点位置： 12345x = [1, 2, 3, 99, 99, 3, 2, 1]x1, x2, x3 = np.split(x, [3, 5])print(x1, x2, x3)&gt;&gt;&gt; [1 2 3] [99 99] [3 2 1] https://docs.scipy.org/doc/numpy/reference/generated/numpy.split.html 参数： ary indices or sections axis 123&gt;&gt;&gt; x = np.arange(9.0)&gt;&gt;&gt; np.split(x, 3)&gt;&gt;&gt; array([ 0., 1., 2.]), array([ 3., 4., 5.]), array([ 6., 7., 8.])] 1234567&gt;&gt;&gt; x = np.arange(8.0)&gt;&gt;&gt; np.split(x, [3, 5, 6, 10])&gt;&gt;&gt;[array([ 0., 1., 2.]), array([ 3., 4.]), array([ 5.]), array([ 6., 7.]), array([], dtype=float64)] np.vsplit和np.hsplitN 分裂点会得到 N + 1 个子数组。 1234567891011121314151617181920212223242526272829grid = np.arange(16).reshape((4, 4))grid&gt;&gt;&gt; array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])upper, lower = np.vsplit(grid, [2])print(upper)print(lower)&gt;&gt;&gt;[[0 1 2 3] [4 5 6 7]] [[ 8 9 10 11] [12 13 14 15]]left, right = np.hsplit(grid, [2])print(left)print(right)&gt;&gt;&gt;[[ 0 1] [ 4 5] [ 8 9] [12 13]] [[ 2 3] [ 6 7] [10 11] [14 15]] https://docs.scipy.org/doc/numpy/reference/generated/numpy.vsplit.html https://docs.scipy.org/doc/numpy/reference/generated/numpy.hsplit.html np.dsplit https://docs.scipy.org/doc/numpy/reference/generated/numpy.split.html 1234&gt;&gt;&gt; x = np.arange(9.0)&gt;&gt;&gt; np.split(x, 3)&gt;&gt;&gt; [array([ 0., 1., 2.]), array([ 3., 4., 5.]), array([ 6., 7., 8.])] 123456789&gt;&gt;&gt; x = np.arange(8.0)&gt;&gt;&gt; np.split(x, [3, 5, 6, 10])&gt;&gt;&gt;[array([ 0., 1., 2.]), array([ 3., 4.]), array([ 5.]), array([ 6., 7.]), array([], dtype=float64)]]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第2章 数组拼接]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[np.concatenate123456789101112# 拼接2个数组x = np.array([1, 2, 3])y = np.array([3, 2, 1])np.concatenate([x, y])&gt;&gt;&gt; array([1, 2, 3, 3, 2, 1])# 拼接3个数组z = [99, 99, 99]print(np.concatenate([x, y, z]))&gt;&gt;&gt; [ 1 2 3 3 2 1 99 99 99] 二维数组拼接12345678910111213141516grid = np.array([[1, 2, 3], [4, 5, 6]])# 沿着第一个轴拼接np.concatenate([grid, grid])&gt;&gt;&gt; array([[1, 2, 3], [4, 5, 6], [1, 2, 3], [4, 5, 6]])# 沿着第二个轴拼接（从0开始索引）np.concatenate([grid, grid], axis=1)&gt;&gt;&gt; array([[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6]]) https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html np.vstack12345678910x = np.array([1, 2, 3])grid = np.array([[9, 8, 7], [6, 5, 4]])# 垂直栈数组np.vstack([x, grid])&gt;&gt;&gt; array([[1, 2, 3], [9, 8, 7], [6, 5, 4]]) https://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html np.hstack1234567# 水平栈数组y = np.array([[99], [99]])np.hstack([grid, y])&gt;&gt;&gt; array([[ 9, 8, 7, 99], [ 6, 5, 4, 99]]) https://docs.scipy.org/doc/numpy/reference/generated/numpy.hstack.html np.dstack https://www.numpy.org/devdocs/reference/generated/numpy.dstack.html 沿着第三个维度拼接数组 123456&gt;&gt;&gt; a = np.array((1,2,3))&gt;&gt;&gt; b = np.array((2,3,4))&gt;&gt;&gt; np.dstack((a,b))&gt;&gt;&gt;array([[[1, 2], [2, 3], [3, 4]]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第2章 数组变形]]></title>
    <url>%2F2019%2F05%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-numpy%E5%85%A5%E9%97%A8-%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E7%BB%84%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook reshape() https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html Gives a new shape to an array without changing its data. 在不改变数据的情况下，进行数组的变形，变成你想要的n行n列。 123456789101112import numpy as npa = np.arange(6)a&gt;&gt;&gt; array([0, 1, 2, 3, 4, 5])b = np.arange(6).reshape((3, 2))b&gt;&gt;&gt; array([[0, 1], [2, 3], [4, 5]]) newaxis() https://stackoverflow.com/questions/29241056/how-does-numpy-newaxis-work-and-when-to-use-it newaxis()可使当前数组的维度增加一个维度（dimension）。 1D array 会变成 2D array 2D array 会变成 3D array 3D array 会变成 4D array 4D array 会变成 5D array 1234567x1 = np.arange(1,10).reshape(3,3)print(x1)# 3行3列&gt;&gt;&gt; array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 切片操作中利用newaxis()： 123456789x1_new = x1[:,np.newaxis]print(x1_new)# dimension (3,1,3)&gt;&gt;&gt; array([[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]]]) 书上的例子12345678910111213141516171819202122232425x = np.array([1, 2, 3])# 通过变形获得的行向量x.reshape((1, 3))&gt;&gt;&gt; array([[1, 2, 3]])# 通过newaxis获得的行向量x[np.newaxis, :]&gt;&gt;&gt; array([[1, 2, 3]])# 通过变形获得的列向量x.reshape((3, 1))&gt;&gt;&gt; array([[1], [2], [3]])# 通过newaxis获得的列向量x[:, np.newaxis]&gt;&gt;&gt; array([[1], [2], [3]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第2章 数据切片]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20numpy%E5%85%A5%E9%97%A8%20%E7%AC%AC2%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[切片语法1x[start:stop:step] 如果以上 3 个参数都未指定，那么它们会被分别设置默认值 start=0、stop= 维度的大小（size of dimension）和 step=1。 一维子数组1234567891011121314151617181920212223x = np.arange(10)x&gt;&gt;&gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])x[:5] # 前五个元素&gt;&gt;&gt; array([0, 1, 2, 3, 4])x[5:] # 索引五之后的元素&gt;&gt;&gt; array([5, 6, 7, 8, 9])x[4:7] # 中间的子数组&gt;&gt;&gt; array([4, 5, 6])x[::2] # 每隔一个元素&gt;&gt;&gt; array([0, 2, 4, 6, 8])x[1::2] # 每隔一个元素，从索引1开始&gt;&gt;&gt; array([1, 3, 5, 7, 9]) 逆序数组1234567x[::-1] # 所有元素，逆序的&gt;&gt;&gt; array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])x[5::-2] # 从索引5开始每隔一个元素逆序&gt;&gt;&gt; array([5, 3, 1]) 多维子数组12345678910111213141516x2&gt;&gt;&gt; array([[12, 5, 2, 4], [ 7, 6, 8, 8], [ 1, 6, 7, 7]])x2[:2, :3] # 两行，三列&gt;&gt;&gt; array([[12, 5, 2], [ 7, 6, 8]])x2[:3, ::2] # 所有行，每隔一列&gt;&gt;&gt; array([[12, 2], [ 7, 8], [ 1, 7]]) 逆序数组12345x2[::-1, ::-1]&gt;&gt;&gt; array([[ 7, 7, 6, 1], [ 8, 8, 6, 7], [ 4, 2, 5, 12]]) 获取数组的行和列一个冒号（:）表示空切片 1234567891011print(x2[:, 0]) # x2的第一列&gt;&gt;&gt; [12 7 1]print(x2[0, :]) # x2的第一行&gt;&gt;&gt; [12 5 2 4]print(x2[0]) #等于x2[0, :]&gt;&gt;&gt; [12 5 2 4] 非副本视图的子数组数组切片返回的是数组数据的视图，而不是数值数据的副本。这一点也是 NumPy 数组切片和 Python 列表切片的不同之处：在 Python 列表中，切片是值的副本。 1234567891011121314151617181920212223242526print(x2)&gt;&gt;&gt; [[12 5 2 4] [ 7 6 8 8] [ 1 6 7 7]] # 从中抽取一个 2×2 的子数组x2_sub = x2[:2, :2]print(x2_sub)&gt;&gt;&gt;[[12 5] [ 7 6]]# 现在如果修改这个子数组，将会看到原始数组也被修改了x2_sub[0, 0] = 99print(x2_sub)&gt;&gt;&gt; [[99 5] [ 7 6]]print(x2)&gt;&gt;&gt; [[99 5 2 4] [ 7 6 8 8] [ 1 6 7 7]] 创建数组的副本copy()函数 12345678910111213141516171819x2_sub_copy = x2[:2, :2].copy()print(x2_sub_copy)&gt;&gt;&gt; [[99 5] [ 7 6]] # 如果修改这个子数组，原始的数组不会被改变x2_sub_copy[0, 0] = 42print(x2_sub_copy)&gt;&gt;&gt; [[42 5] [ 7 6]]print(x2)&gt;&gt;&gt;[[99 5 2 4] [ 7 6 8 8] [ 1 6 7 7]]]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第2章 数据索引]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20numpy%E5%85%A5%E9%97%A8%20%E7%AC%AC2%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook 一维数组里进行索引123456789101112131415161718192021222324import numpy as npnp.random.seed(0)x1 = np.random.randint(10, size=6) # 一维数组x2 = np.random.randint(10, size=(3, 4)) # 二维数组x3 = np.random.randint(10, size=(3, 4, 5)) # 三维数组x1&gt;&gt;&gt; array([5, 0, 3, 3, 7, 9])x1[0]&gt;&gt;&gt; 5x1[4] &gt;&gt;&gt; 7x1[-1]&gt;&gt;&gt; 9x1[-2]&gt;&gt;&gt; 7 多维数组里进行索引1234567891011121314151617181920x2&gt;&gt;&gt; array([[3, 5, 2, 4], [7, 6, 8, 8], [1, 6, 7, 7]])x2[0, 0]&gt;&gt;&gt; 3x2[2, 0]&gt;&gt;&gt; 1x2[2, -1]&gt;&gt;&gt; 7x2[0, 0] = 12x2&gt;&gt;&gt; array([[12, 5, 2, 4], [ 7, 6, 8, 8], [ 1, 6, 7, 7]]) 修改浮点数如果把x1的位置0元素改为浮点数，那结果会被截短成整型。 1234x1[0] = 3.14159x1&gt;&gt;&gt; array([3, 0, 3, 3, 7, 9])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第2章 数据属性]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20numpy%E5%85%A5%E9%97%A8%20%E7%AC%AC2%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook NumPy数组的属性 ndim 数组的维度 shape 数组每个维度的大小 size 数组的总大小 dtype 数组的数据类型 itemsize 每个数组元素字节的大小 nbytes 数组总字节大小的属性 用例子体会123456789101112131415161718192021222324import numpy as npnp.random.seed(0)x1 = np.random.randint(10, size=6) # 一维数组x2 = np.random.randint(10, size=(3, 4)) # 二维数组x3 = np.random.randint(10, size=(3, 4, 5)) # 三维数组print("x3 ndim: ", x3.ndim)print("x3 shape:", x3.shape)print("x3 size: ", x3.size)&gt;&gt;&gt; x3 ndim: 3&gt;&gt;&gt; x3 shape: (3, 4, 5)&gt;&gt;&gt; x3 size: 60print("dtype:", x3.dtype)&gt;&gt;&gt;dtype: int64print("itemsize:", x3.itemsize, "bytes")print("nbytes:", x3.nbytes, "bytes")&gt;&gt;&gt; itemsize: 8 bytes&gt;&gt;&gt; nbytes: 480 bytes]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第1章 创建数组方法和数据类型]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20numpy%E5%85%A5%E9%97%A8%20%E7%AC%AC1%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook 从头创建数组用 NumPy 内置的方法从头创建数组。 创建一个长度为10的数组，数组的值都是0 1234import numpy as npnp.zeros(10, dtype=int)# output: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 创建一个3×5的浮点型数组，数组的值都是1 123456np.ones((3, 5), dtype=float)# output# array([[1., 1., 1., 1., 1.],# [1., 1., 1., 1., 1.],# [1., 1., 1., 1., 1.]]) 创建一个3×5的浮点型数组，数组的值都是3.14 123456np.full((3, 5), 3.14)#output# array([[3.14, 3.14, 3.14, 3.14, 3.14],# [3.14, 3.14, 3.14, 3.14, 3.14],# [3.14, 3.14, 3.14, 3.14, 3.14]]) 创建一个线性序列数组，从0开始，到20结束，步长为2。（它和内置的range()函数类似） 123np.arange(0, 20, 2)#output: array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]) 创建一个5个元素的数组，这5个数均匀地分配到0~1 123np.linspace(0, 1, 5)#output: array([0. , 0.25, 0.5 , 0.75, 1. ]) 创建一个3×3的、在0~1均匀分布的随机数组成的数组 123456np.random.random((3, 3))#output#array([[0.94795687, 0.62658297, 0.4240733 ],# [0.75686519, 0.46357097, 0.58682988],# [0.37997183, 0.28707067, 0.67190137]]) 创建一个3×3的、均值为0、标准差为1的，正态分布的随机数数组 123456np.random.normal(0, 1, (3, 3))#output#array([[ 0.1348332 , -1.93013655, 1.21003072],# [ 1.41562771, 0.29064906, 1.09749629],# [-0.16664035, -0.67962834, -0.54942727]]) 创建一个3×3的、[0, 10)区间的随机整型数组 123456np.random.randint(0, 10, (3, 3))#output#array([[8, 0, 5],# [6, 5, 9],# [9, 9, 0]]) 创建一个3×3的单位矩阵 123456np.eye(3)#output#array([[1., 0., 0.],# [0., 1., 0.],# [0., 0., 1.]]) 创建一个由3个整型数组成的未初始化的数组，数组的值是内存空间中的任意值 123np.empty(3)#output: array([1., 1., 1.]) NumPy标准数据类型构建数组时，可以用以下2种方式指定数据类型： 用字符串参数 123np.zeros(10, dtype='int16')#output: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int16) 用相关NumPy对象来指定 123np.zeros(10, dtype=np.int16)#output: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int16) NumPy标准数据类型表格： http://numpy.org/ 数据类型 描述 bool_ 布尔值（真、True 或假、False），用一个字节存储 int_ 默认整型（类似于 C 语言中的 long，通常情况下是 int64 或 int32） intc 同 C 语言的 int 相同（通常是 int32 或 int64） intp 用作索引的整型（和 C 语言的 ssize_t 相同，通常情况下是 int32 或 int64） int8 字节（byte，范围从–128 到 127） int16 整型（范围从–32768 到 32767） int32 整型（范围从–2147483648 到 2147483647） int64 整型（范围从–9223372036854775808 到 9223372036854775807） uint8 无符号整型（范围从 0 到 255） uint16 无符号整型（范围从 0 到 65535） uint32 无符号整型（范围从 0 到 4294967295） uint64 无符号整型（范围从 0 到 18446744073709551615） float_ float64 的简化形式 float16 半精度浮点型：符号比特位，5 比特位指数（exponent），10 比特位尾数（mantissa） float32 单精度浮点型：符号比特位，8 比特位指数，23 比特位尾数 float64 双精度浮点型：符号比特位，11 比特位指数，52 比特位尾数 complex_ complex128 的简化形式 complex64 复数，由两个 32 位浮点数表示 complex128 复数，由两个 64 位浮点数表示]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 numpy入门 第1章 python的特殊]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20numpy%E5%85%A5%E9%97%A8%20%E7%AC%AC1%E7%AB%A0%20python%E7%9A%84%E7%89%B9%E6%AE%8A%2F</url>
    <content type="text"><![CDATA[https://github.com/jakevdp/PythonDataScienceHandbook Numpy入门Numerical Python，提供了高效存储和操作密集数据缓存的接口。 导入Numpy 1import numpy as np 理解Python中的数据类型学习数据科学，我们要理解数据是如何被储存和操作的。 python易用性-动态输入静态类型的语言（如 C 或 Java）往往需要每一个变量都明确地声明， 而动态类型的语言（例如 Python）可以跳过这个特殊规定。 Python整型不仅仅是一个整型Python 3.4 中的一个整型实际上包括 4 个部分。 ob_refcnt 是一个引用计数，它帮助 Python 默默地处理内存的分配和回收。 ob_type 将变量的类型编码。 ob_size 指定接下来的数据成员的大小。 ob_digit 包含我们希望 Python 变量表示的实际整型值。 Python列表不仅仅是一个列表整型值列表 123456789101112L = list (range(10))print(L)# output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]type(L)# output:listtype(L[0])# output:int 字符串列表 123456789L2 = [str(c) for c in L]print(L2)# output: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']type(L2[0])# output: str 异构列表 1234L3 = [True, "2", 3.0, 4][type(item) for item in L3]# output: [bool, str, float, int] Python中的固定类型数组array模块创建统一类型的密集数组 12345678import arrayL = list(range(10))print(L)A = array.array('i', L)A# output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# array('i', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 从Python列表创建数组NumPy 要求数组必须包含同一类型的数据。 123456# 导入Numpyimport numpy as np# 创建数组np.array([1, 4, 2, 5, 3])#output: array([1, 4, 2, 5, 3]) 如果数据类型不匹配，Numpy向上转换： 12345import numpy as npnp.array([3.14, 4, 2, 3])# 整型int转换为浮点型float# output: array([3.14, 4. , 2. , 3. ]) 也可以用dtype关键词去设置数组的数据类型： 1234import numpy as npnp.array([1, 2, 3, 4], dtype='float32')# output: array([1., 2., 3., 4.], dtype=float32) 多维数组： 12345678# 嵌套列表构成的多维数组import numpy as npnp.array([range(i, i + 3) for i in [2, 4, 6]])#output#array([[2, 3, 4],# [4, 5, 6],# [6, 7, 8]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>数据科学</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.random.seed使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-random-seed%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://www.sharpsightlabs.com/blog/numpy-random-seed/ PSEUDO-RANDOM NUMBER首先提一下 “pseudo-random number”（伪随机数），它不是真正的随机，而是用确定性的算法计算出来的均匀分布随机数序列。 https://zh.wikipedia.org/zh-hans/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7 那因为伪随机数是确定的，所以它们是可重复的（repeatable）。 seed的结果1234np.random.seed(0)np.random.randint(10, size = 5)&gt;&gt;&gt; array([5, 0, 3, 3, 7]) 如果你把以上代码再重复run一次，会发现结果是一样的。 numpy.random.seed函数会把 输出 （ seed value）传给那个在numpy里产生伪随机数的算法。 搭配numpy.random.seed经常和numpy.random.randint一起使用。 THE SYNTAX OF NUMPY RANDOM SEED只有一个参数，那就是seed value。]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.empty使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-empty%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://www.runoob.com/numpy/numpy-array-creation.html https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty.html numpy.emptyReturn a new array of given shape and type, without initializing entries. 返回 一个指定形状（shape）、数据类型（dtype）且未初始化的数组。 参数 shape dtype order 例子1234import numpy as npnp.empty(4)# array([1., 0., 0., 1.]) 1234np.empty([2, 2])# array([[1., 0.],# [0., 1.]]) 12345np.empty([3, 2], dtype=int)# array([[-618601952, 346],# [ 0, 0],# [ 1, 0]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.eye使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-eye%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html https://www.numpy.org.cn/article/basics/different_ways_create_numpy_arrays.html#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96Numpy%E5%87%BD%E6%95%B0 https://www.programcreek.com/python/example/6118/numpy.eye 对角矩阵Return a 2-D array with ones on the diagonal and zeros elsewhere. 返回一个 对角线是1，其余是0的 2维数组。 参数 N （行） M （列） K （Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal） dtype 数据类型 order （Whether the output should be stored in row-major (C-style) or column-major (Fortran-style) order in memory） 例子N+dtype12345import numpy as npnp.eye(2, dtype=int)#array([[1, 0],# [0, 1]]) 12345np.eye(3, dtype=int)#array([[1, 0, 0],# [0, 1, 0],# [0, 0, 1]]) 123456np.eye(4, dtype=int)#array([[1, 0, 0, 0],# [0, 1, 0, 0],# [0, 0, 1, 0],# [0, 0, 0, 1]]) N+M1234np.eye(2, 2)#array([[1., 0.],# [0., 1.]]) 12345np.eye(3, 6)#array([[1., 0., 0., 0., 0., 0.],# [0., 1., 0., 0., 0., 0.],# [0., 0., 1., 0., 0., 0.]]) N+K12345np.eye(3, k=1)#array([[0., 1., 0.],# [0., 0., 1.],# [0., 0., 0.]]) 123456np.eye(4, k=1)#array([[0., 1., 0., 0.],# [0., 0., 1., 0.],# [0., 0., 0., 1.],# [0., 0., 0., 0.]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.random.randint使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-random-randint%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://docs.scipy.org/doc/numpy-1.16.1/reference/generated/numpy.random.randint.html https://blog.csdn.net/tintinetmilou/article/details/79854725 https://www.programcreek.com/python/example/55590/numpy.random.randint https://www.tutorialspoint.com/How-to-use-Python-Numpy-to-generate-Random-Numbers https://segmentfault.com/a/1190000016097466 https://zhuanlan.zhihu.com/p/26889091 random.randintnumpy.random.randint可以创建范围是[low, high]之间的随机整数数组。 有以下几种参数： low high size dtype 来用例子学习吧！ 指定Low+high创建随机整数数组，返回[1, 10]之间的整数： 12import numpy as npnp.random.randint(low = 1, high = 10, dtype=int) 结果只会是1~9。 不指定high12import numpy as npnp.random.randint(low = 1, dtype=int) 不指定high参数，结果只是0。也就是当我们不指定high参数时，low参数的值是数组里的最大范围。 12import numpy as npnp.random.randint(low = 5, dtype=int) 这个的结果只是0~4。证明了low参数的值是数组里的最大范围。 指定size1234import numpy as npnp.random.randint(low = 3, size = 1)# 结果是 array([0/1/2]) 1234import numpy as npnp.random.randint(low = 3, size = 2)# 结果是 array([0~2, 0~2]) 12345import numpy as npnp.random.randint(low = 5, size = (2, 2))# 结果是 array([[0~4, 0~4],# [0~4, 0~4]]) 只指定size123&gt;&gt;&gt; np.random.randint(2, size=10)&gt;&gt;&gt; array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) 123&gt;&gt;&gt; np.random.randint(1, size=10)&gt;&gt;&gt; array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 1234&gt;&gt;&gt; np.random.randint(5, size=(2, 4))&gt;&gt;&gt; array([[4, 0, 2, 1], [3, 2, 2, 0]]) 没有明确指定12345&gt;&gt;&gt; np.random.randint(1, 5)# 返回[1, 5)之间随机的一个数字 &gt;&gt;&gt; 0~4]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.random使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-random%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://www.sharpsightlabs.com/blog/numpy-random-normal/ Normal distrubutionThe NumPy random normal function generates a sample of numbers drawn from the normal distribution（正态分布、常态分布）, otherwise called the Gaussian distribution（高斯分布）. 参考链接：维基百科 NUMPY RANDOM NORMAL GENERATES NORMALLY DISTRIBUTED NUMBERSrandom normal函数可以让你创建一个包含正态分布数据的numpy数组。 下图是我们用直方图绘制数据： 正态分布数据，就像bell（钟、铃铛），所以经常被称为“钟形曲线”。 接下来我们看看语法。 THE SYNTAX OF NUMPY RANDOM NORMAL不要忘了导入模块： 1import numpy as np np.random.normal()函数有3个参数： loc scale size THE PARAMETERS OF THE NP.RANDOM.NORMAL FUNCTIONloc：控制函数的平均值（Mean），默认值是0。 scale：控制正态分布的标准偏差，默认值是1。 size：控制输出的大小和形状。 If you provide a single integer, x, np.random.normal will provide x random normal values in a 1-dimensional NumPy array. 如果 size = x，那np.random.normal函数就会提供一个有x个正态分布数值的1维numpy数组。 For example, if you specify size = (2, 3), np.random.normal will produce a numpy array with 2 rows and 3 columns. It will be filled with numbers drawn from a random normal distribution. 例如，你指定 size = (2, 3)，那就会产生一个2行3列的numpy数组。 THE NP.RANDOM.RANDN FUNCTION还有一个类似的函数：np.random.randn()。 这个代码： 12np.random.seed(1)np.random.normal(loc = 0, scale = 1, size = (3,3)) 等于下面这个： 12np.random.seed(1)np.random.randn(3, 3) EXAMPLES: HOW TO USE THE NUMPY RANDOM NORMAL FUNCTIONDRAW A SINGLE NUMBER FROM THE NORMAL DISTRIBUTION123np.random.normal(1)# 等于： np.random.normal(size = 1, loc = 0, scale = 1) DRAW 5 NUMBERS FROM THE NORMAL DISTRIBUTION1np.random.normal(5) CREATE A 2-DIMENSIONAL NUMPY ARRAY OF NORMALLY DISTRIBUTED VALUES12345np.random.seed(42)np.random.normal(size = (2, 3))#array([[ 1.62434536, -0.61175641, -0.52817175],# [-1.07296862, 0.86540763, -2.3015387 ]]) GENERATE NORMALLY DISTRIBUTED VALUES WITH A SPECIFIC MEAN1234567np.random.seed(42)np.random.normal(size = 1000, loc = 50)# array([ 50.49671415, 49.8617357 , 50.64768854, 51.52302986,# 49.76584663, 49.76586304, 51.57921282, 50.76743473,# 49.53052561, 50.54256004, 49.53658231, 49.53427025 # ... GENERATE NORMALLY DISTRIBUTED VALUES WITH A SPECIFIC STANDARD DEVIATION1234567np.random.seed(42)np.random.normal(size = 1000, scale = 100)#array([ 4.96714153e+01, -1.38264301e+01, 6.47688538e+01,# 1.52302986e+02, -2.34153375e+01, -2.34136957e+01,# 1.57921282e+02, 7.67434729e+01, -4.69474386e+01# ... 我们可以用std()方法去计算标准偏差： 1234np.random.seed(42)np.random.normal(size = 1000, scale = 100).std()# 99.695552529463015 HOW TO USE THE LOC AND SCALE PARAMETER IN NP.RANDOM.NORMAL12np.random.seed(42)np.random.normal(size = 1000, loc = 50, scale = 100) numpy.random.normal https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.linspace使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-linspace%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Numpy refer https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0) Parameters start : array_like The starting value of the sequence. 序列的初始值。 stop : array_like The end value of the sequence, unless endpoint is set to False. In that case, the sequence consists of all but the last of num + 1 evenly spaced samples, so that stop is excluded. Note that the step size changes when endpoint is False. num : int, optional Number of samples to generate. Default is 50. Must be non-negative. 默认值是50，必须是非负数。 endpoint : bool, optional If True, stop is the last sample. Otherwise, it is not included. Default is True. retstep : bool, optional If True, return (samples, step), where step is the spacing between samples. dtype : dtype, optional The type of the output array. If dtype is not given, infer the data type from the other input arguments. axis : int, optional The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end. Returns samples : ndarray There are num equally spaced samples in the closed interval [start, stop] or the half-open interval [start, stop) (depending on whether endpoint is True or False). step : float, optional Only returned if retstep is True Size of spacing between samples. 例子12345678&gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)array([ 2. , 2.25, 2.5 , 2.75, 3. ])&gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)array([ 2. , 2.2, 2.4, 2.6, 2.8])&gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)(array([ 2. , 2.25, 2.5 , 2.75, 3. ]), 0.25) Graphical illustration: 1234567891011121314&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; N = 8&gt;&gt;&gt; y = np.zeros(N)&gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)&gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)&gt;&gt;&gt; plt.plot(x1, y, 'o')[&lt;matplotlib.lines.Line2D object at 0x...&gt;]&gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')[&lt;matplotlib.lines.Line2D object at 0x...&gt;]&gt;&gt;&gt; plt.ylim([-0.5, 1])(-0.5, 1)&gt;&gt;&gt; plt.show() Numpy sharpsightlab https://www.sharpsightlabs.com/blog/numpy-linspace/ 先看个简单的例子： 1np.linspace(start = 0, stop = 100, num = 5) 看这张图可能更加好理解： 可以看出，在我们指定的范围内（从0开始，100为结束），有5个元素（0、25、50、75、100）。 另外，如果指定endpoint = False，那100这个值就不包括在内。num在这里我们指定的是5，如果没有指定，那默认值是50。 这张图里有3个参数，分别是start、stop、num。这会是我们很常用的参数。 OK，接下来我们看看默认写法是怎么样的： 1np.linspace(0, 100, 5) 相当于： 1np.linspace(start = 0, stop = 100, num = 5) 例子123&gt;&gt;&gt; np.linspace(start = 0, stop = 1, num = 11)&gt;&gt;&gt; array([ 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]) 123&gt;&gt;&gt; np.linspace(start = 0, stop = 100, num = 11)&gt;&gt;&gt; array([ 0., 10., 20., 30., 40., 50., 60., 70., 80., 90., 100.]) 123&gt;&gt;&gt; np.linspace(start = 1, stop = 5, num = 4, endpoint = False)&gt;&gt;&gt; array([ 1., 2., 3., 4.]) 123&gt;&gt;&gt; np.linspace(start = 0, stop = 100, num = 5, dtype = int)&gt;&gt;&gt; array([ 0, 25, 50, 75, 100])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.full使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-full%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[full函数 用确定的数值创建数组1&gt;&gt;&gt; np.full((n行, n列), value) 例子123&gt;&gt;&gt; np.full((2, 2), 10)&gt;&gt;&gt; array([[10, 10], [10, 10]]) 1234&gt;&gt;&gt;np.full((2,2), 3)&gt;&gt;&gt;array([[3, 3], [3, 3]]) 1234&gt;&gt;&gt; np.full((3, 5), 7)&gt;&gt;&gt;array([[ 7., 7., 7., 7., 7.], [ 7., 7., 7., 7., 7.], [ 7., 7., 7., 7., 7.]]) 1234&gt;&gt;&gt; np.full((3, 5), 7, dtype=int)&gt;&gt;&gt;array([[7, 7, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]) https://github.com/jakevdp/PythonDataScienceHandbook 创建一个3×5的浮点型数组，数组的值都是3.14： 123456np.full((3, 5), 3.14)#output# array([[3.14, 3.14, 3.14, 3.14, 3.14],# [3.14, 3.14, 3.14, 3.14, 3.14],# [3.14, 3.14, 3.14, 3.14, 3.14]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.arange使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-arange%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://www.sharpsightlabs.com/blog/numpy-arange/ The NumPy arange function returns evenly spaced numeric values within an interval, stored as a NumPy array (i.e., an ndarray object). arrange()函数可以生成等间隔的数值。 1numpy.arange(5) 创建了从0到4的5个等间隔的数值。 继续往下走。 使用arange()函数时，我们有4个参数可以用。 start 指定数值的开头 stop 指定末尾，这个数值不会被包括在结果里 step 数值之间的间隔 dtype 数据类型 来看例子体会吧 先导入模块1import numpy as np 创一个简单的1np.arange(stop = 5) 我们没有指定start，所以数组的开头是“0”。接下来，“stop = 5”指定了停止数值为5，到5就结束了，不包含5。 同样地，由于我们没有指定 “step”，默认间隔为”1“。最后，因为5是整数，尽管我们没有指定数据类型，python默认用5的数据类型，也就是整数(int)作为数组的数据类型。 1np.arange(5) 另外，如果我们没有指定参数名，会默认是”stop“。 创间隔为2的创建从0到8，增数为2： 1np.arange(start = 0, stop = 8, step = 2) 指定数据类型1np.arange(start = 1, stop = 5, dtype = 'float') 创建2维数组需要搭配方法reshape。 先别急，我们先看看这个： 从1到9的1维数组 1np.arange(start = 1, stop = 10, step = 1) 再看这个，使用方法reshape()： 1np.arange(start = 1, stop = 10, step = 1).reshape((3,3)) 可以看到，使用了reshape()方法后，变成了3行3列的2维数组（a 2-dimensional array）。]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.ones使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-ones%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://docs.scipy.org/doc/numpy-1.16.1/reference/generated/numpy.ones.html?highlight=ones numpy.ones(shape, dtype=None, order=’C’) Return a new array of given shape and type, filled with ones. 例子12&gt;&gt;&gt; np.ones(5)array([ 1., 1., 1., 1., 1.]) 12&gt;&gt;&gt; np.ones((5,), dtype=int)array([1, 1, 1, 1, 1]) 123&gt;&gt;&gt; np.ones((2, 1))array([[ 1.], [ 1.]]) 1234&gt;&gt;&gt; s = (2,2)&gt;&gt;&gt; np.ones(s)array([[ 1., 1.], [ 1., 1.]])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy.zeros使用方法]]></title>
    <url>%2F2019%2F05%2F19%2Fnumpy-zeros%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[https://www.sharpsightlabs.com/blog/numpy-zeros-python/ 快速回顾numpy array A NumPy array is basically like a container that holds numeric data that’s all of the same data type. I’m simplifying things a little, but that’s the essence of them. We can create a very simple NumPy array as follows: Numpy数组就像是一个容器，里面装着相同数据类型的数据。我们可以这样创建数组： 123import numpy as npnp.array([[1,2,3,4,5,6],[7,8,9,10,11,12]]) 我们创建了一个拥有2行6列的二维数组。所有数据都是整数（integers）。记住，在numpy的数组里，所有数据都必须是相同的数据类型。 当然数组可以是更加复杂的三维数组或者N维数组。 创建空的数组Arrays我们可以用Numpy array()函数创建一个空的，全是数字0的数组。 1np.array([[0,0,0],[0,0,0]]) 如果你需要创建更加大的多维数组，效率就不够高了： 123np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]) 别怕，我们可以用 Numpy reshape()方法： 1np.zeros(90).reshape((3,30)) 这个方法也不是很好，我们有更好的。 走，去看 zeros函数！ Zeros函数语法这个函数可以让你创建只有0的数组。 更重要地，这个函数可以让你指定数组的维度（dimensions）。也可以让你指定数据类型。 Then inside the zeros() function, there is a set of arguments. The first positional argument is a tuple of values that specifies the dimensions of the new array. Next, there’s an argument that enables you to specify the data type. If you don’t specify a data type, np.zeros() will use floats by default. 可以简单地看成，np.zeros(shape = (n行, m列), dtype = 数据类型)。如果不指定数据类型，会默认为floats。 例子例子1有5个0，1维数组 1np.zeros(5) 那我们可以看到数组里有5个元素，都是0。并且都是浮点数。 例子2用 dtype 指定数据类型，整数(int)。 1np.zeros(3, dtype = int) 还可以用dtype测试下数据的类型是不是整数int： 123&gt;&gt;&gt; np.zeros(3, dtype = int).dtype&gt;&gt;&gt; dtype('int64') 例子3指定shape： 1np.zeros(shape = (2, 3)) 也可以写成这样： 1np.zeros((2, 3)) 例子4指定shape和dtype： 1np.zeros(shape = (3, 5), dtype = 'int') 我们创建了一个3行5列的都是0的矩阵。 例子5接下来我们可以试试更加大的数组： 1np.zeros(shape = (3, 3, 5), dtype = 'int') https://docs.scipy.org/doc/ https://www.numpy.org/devdocs/reference/generated/numpy.zeros.html?highlight=zeros numpy.zeros(shape, dtype=float, order=’C’) Return a new array of given shape and type, filled with zeros. Parametersshape : int or tuple of ints Shape of the new array, e.g., (2, 3) or 2. dtype : data-type, optional The desired data-type for the array, e.g., numpy.int8. Default is numpy.float64. order : {‘C’, ‘F’}, optional, default: ‘C’ Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory. Returnsout : ndarray Array of zeros with the given shape, dtype, and order. 例子12&gt;&gt;&gt; np.zeros(5)array([ 0., 0., 0., 0., 0.]) 12&gt;&gt;&gt; np.zeros((5,), dtype=int)array([0, 0, 0, 0, 0]) 123&gt;&gt;&gt; np.zeros((2, 1))array([[ 0.], [ 0.]]) 1234&gt;&gt;&gt; s = (2,2)&gt;&gt;&gt; np.zeros(s)array([[ 0., 0.], [ 0., 0.]]) 123&gt;&gt;&gt; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtypearray([(0, 0), (0, 0)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])]]></content>
      <categories>
        <category>数据科学</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data science</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + NextT主题配置快速教程]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo-NextT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言博客的初衷是为了写文章、发布文章，追求简洁和加载速度。最终选择了NextT主题。 NextT主题Github地址 NextT主题官方文档 更换主题下载NextT主题 下载后解压ZIP，把文件夹名字修改成NextT，并把主题文件夹复制到 D:\Myblog\themes里面。 修改主题用vs code（你也可以用其他编辑器）打开 D:\Myblog\_config.yml，搜索theme，修改为：NextT，保存并退出。 博客面貌仔细修改改主题样式D:\Myblog\themes\NextT\_config.yml，搜索 Scheme——&gt; 改用 scheme: Gemini 语言设置NextT很容易出现德语的情况，所以打开 D:\Myblog\_config.yml，把语言改成： 1language: en 添加目录栏选项D:\Myblog\themes\NextT\_config.yml，搜索 menu——&gt; 设置 about、archives、categories、tags、Books、Video、Game。 添加新的栏： 123456789menu: about: /about/ || user archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags Books: /Books/ || eye Video: /Video/ || play-circle Game: /Game/ || gamepad #home: / || home 之后在D:\Myblog右键Git Bash here： 123$ hexo new page "archives"#以及其他菜单项categories、tags、Books、Video、Game。 打开 D:\Myblog\source，打开对应md文件，一一修改type： 123title: categoriesdate: 2019-05-15 17:29:26type: &quot;categories&quot; 代码块主题D:\Myblog\themes\NextT\_config.yml，搜索 highlight_theme——&gt; 改为 night eighties 侧边栏D:\Myblog\themes\NextT\_config.yml，搜索 social——&gt;开启微博 首页文章摘要D:\Myblog\themes\NextT\_config.yml，搜索 auto_excerpt——&gt;开启 标签图标更改打开D:\Myblog\themes\NextT\layout\_marcro\post.swig文件，搜索 post_tags，将 #号 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 添加背景动态js https://github.com/theme-next/theme-next-canvas-nest D:\Myblog\themes\NextT文件夹下，Git Bash here： 1$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 打开D:\Myblog\themes\NextT\_config.yml，修改： 1234567canvas_nest: enable: true onmobile: true # display on mobile or not color: "255,0,0" # RGB values, use ',' to separate, 改成红色了 opacity: 0.7 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 150 # the number of lines 加载条 https://github.hubspot.com/pace/docs/welcome/ PS：如果网页加载慢，就关掉这个 D:\Myblog\themes\NextT文件夹下，Git Bash here： 1$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace D:\Myblog\themes\NextT\_config.yml 12pace: truepace_theme: pace-theme-big-counter 关注Github http://tholman.com/github-corners/ 打开D:\Myblog\themes\NextT\layout\_layout.swig文件，搜索&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 将复制的内容粘贴到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面，如下： 1&lt;a href=&quot;https://github.com/sailorlisa&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;92&quot; height=&quot;92&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#b495e3; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 也可以修改D:\Myblog\themes\NextT\_config.yml里: 1234github_banner: enable: true permalink: https://github.com/sailorlisa title: Follow me on GitHub 白猫插件 Github地址：https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 123$ npm install --save hexo-helper-live2d$ npm install live2d-widget-model-tororo 之后在D:\Myblog\_config.yml最后添加内容： 1234567891011121314151617# 白猫模型live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-tororo display: position: right width: 150 height: 300 mobile: show: false #手机上不显示 图片文件夹插件1.将 D:\Myblog\_config.yml文件中的 post_asset_folder 选项设为 true 2.D:\Myblog，右键Git Bash here，输入： 1$ npm install hexo-asset-image --save 添加搜索栏D:\Myblog，右键Git Bash here，输入： 1$ npm install hexo-generator-searchdb --save D:\Myblog\_config.yml添加： 123456#表示站内搜索search: path: search.xml field: post format: html limit: 10000 D:\Myblog\themes\NextT\_config.yml，搜索local_search： 12local_search: enable: true 标签云 https://github.com/MikeCoder/hexo-tag-cloud D:\Myblog，右键Git Bash here，输入： 1$ npm install hexo-tag-cloud --save D:\Myblog\themes\NextT\layout\_macro\sidebar.swig，然后添加内容： 123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&apos;/js/tagcloud.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&#123;&#123; url_for(&apos;/js/tagcanvas.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; D:\Myblog\_config.yml添加： 1234567# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: '#333' textHeight: 22 outlineColor: '#E2E1D1' maxSpeed: 0.2 最后预览部署1234$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s#预览之后没问题就部署$ hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>主题</tag>
        <tag>NextT</tag>
        <tag>theme</tag>
        <tag>博客</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+Github搭建个人博客快速教程]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 推荐hexo搭建博客详细教程：&lt;https://eirunye.github.io/categories/Hexo/ 由于同内容的教程实在太多，感觉没多大必要再写。所以简单记录下快速搭建个人博客的流程，方便自己使用。 提前准备 Github 注册账号 Node.js 下载，安装 Git 下载，安装 部署博客Git配置在桌面，右键Git Bash here： 123$ git config --global user.name "sailorlisa" $ git config --global user.email "sailorlisa@outlook.com" 登陆Github，创建新的仓库——&gt;Repository name 为 sailorlisa.github.io——&gt;Public——&gt;Creating repository。 SSH配置在桌面，右键Git Bash here： 1$ ssh-keygen -t rsa -C "sailorlisa@outlook.com" 遇到提示，要你输入密码，按Enter跳过。 上面显示C盘路径里有我的Public key，找到对应路径文件，右键，用记事本打开，复制内容。 接下来去github，点击自己头像下的Settings——&gt;Personal settings——&gt;SSH and GPG keys——&gt;New SSH key。 把刚刚复制的一长串内容粘贴在Key栏，Title填hexoblog。之后点Add SSH key。 安装hexo在桌面，右键Git Bash here： 1234567$ ssh git@github.com$ ssh -T git@github.com #验证SSH是否有效$ npm -v #看看有没有安装npm$ npm install -g hexo #安装hexo博客框架 在D盘创建文件夹“Myblog”，在文件夹内 右键Git Bash here： 1234567$ hexo init$ npm install$ npm install hexo-deployer-git --save #能让你使用hexo deploy命令上传blog到github上$ hexo server 鼠标右键复制localhost:4000，用浏览器进入，预览下看看有没有问题。 没有问题后，打开D盘Myblog文件夹里，找到_config.yml（站点配置文件），右键用vs code打开，下滚，找到deploy，修改后保存。 1234deploy: type: git repository: git@github.com:sailorlisa/sailorlisa.github.io.git branch: master repository后面的内容是来自这里： 修改后回到D盘Myblog文件夹，右键Git Bash here： 1$ hexo g &amp;&amp; hexo s 预览下，没问题之后退出，然后去就换主题和配置主题。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook Cheat Sheet中文]]></title>
    <url>%2F2019%2F05%2F16%2FJupyter-Notebook-Cheat-Sheet%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[https://github.com/FavioVazquez/ds-cheatsheets Working with Different Programming Languages Asking For Help Two Modes Saving/Loading Notebooks Writing Code And Text1 Writing Code And Text2 Widgets]]></content>
      <tags>
        <tag>python</tag>
        <tag>jupyter</tag>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SynthWave'84 - VS Code使用流程]]></title>
    <url>%2F2019%2F05%2F16%2FSynthWave-84-VS-Code%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[赛博朋克风，好看！ 安装之前Github地址：https://github.com/robb0wen/synthwave-vscode，先看开发者写的文档 下载安装vs code：https://code.visualstudio.com/ 配置主题下载安装theme 打开vs code，点击​ 文件 ——&gt; 首选项——&gt; 扩展（Ctrl + Shift + X）。 在搜索扩展里搜索 SynthWave，点击 安装。 再次在搜索扩展里搜索 Custom CSS and JS Loader，点击 安装。 在vs code里，点击 文件 ——&gt; 新建文件，打开网址，把synthwave84.css里的所有代码复制粘贴过去，保存，文件命名为 synthwave84.css，下拉保存类型为css，点击确定。 接下来我们需要修改vs code的settings.json： 最快的方法：点击 文件 ——&gt; 首选项 ——&gt; 设置——&gt; 扩展——&gt;在settings.json中编辑，弹出之后，右键标签，选择 在资源管理器中显示 ，就能自动打开路径文件夹（C:\Users\dell\AppData\Roaming\Code\User）了。 回到vs code，settings.json文件，修改代码，引用刚刚的css文件，windows用户在后面复制粘贴以下内容并保存： 12345&#123; "vscode_custom_css.imports": [ "file:///D:/synthwave84.css" ]&#125; 注意：自己修改file后面的路径，你的css文件保存在哪里，就用对应路径。 修改完后，win用户使用快捷键 Ctrl + Shift + P，输入 Enable custom CSS and JS ， 找到后鼠标点击一下，会出现提示： 点击Restart Visual Studio Code。 点击旁边的齿轮按钮，选择不再显示这条提醒。 如果还是没有发光效果，使用快捷键 Ctrl + Shift + P，输入 reload custom CSS and JS， 找到后鼠标点击一下，就可以看到发光效果了，不会很刺眼： 不稳定的插件 VS code doesn’t natively support text effects and as a result, the glow is experimental. It’s likely to be buggy and, whilst it looks rad, it isn’t intended for extended use. 文档上有这么一句话，注意这个Custom CSS and JS Loader 插件很容易坏掉，不是主题的问题。希望以后这个插件更新后能避免这种情况~ 更新 Every time you update VS code, you will need to repeat this step to re-enable custom CSS and JS. Similarly, when the theme updates, you will need to copy the updated css to your chosen location. This is less than ideal, but until VS code add the option to use custom CSS natively, it’s unfortunately the only option. 每次我们更新vs code，都需要重复上面的步骤去re-enable custom CSS and JS。 同样地，主题有了更新后，你也需要去复制最新的css文件去覆盖你的旧css文件。 关掉发光效果和卸载 The glow effect started as a joke and was never intended for long-term coding sessions. If you want to turn it off, you can disable it at any time by opening your command palette with Ctrl + Shift + P or Shift + ⌘ + P and choose “Disable custom CSS”. If you decide to change to a different theme altogether, you will also need to disable the custom css in this way. You may also wish to remove the file path from your settings.json. 这个发光效果不是很稳定，如果想要关掉，打开vs code，使用快捷键 Ctrl + Shift + P，输入 Disable custom CSS ，找到后鼠标点击一下。 如何卸载主题？ 先根据上面的步骤把发光效果关掉，然后打开settings.json，把之前添加的那行代码删掉 参考资料1.https://github.com/robb0wen/synthwave-vscode 2.https://jinkey.ai/post/tech/ru-he-pei-zhi-tou-ming-fa-guang-de-sao-qi-vscode]]></content>
      <categories>
        <category>主题</category>
      </categories>
      <tags>
        <tag>主题</tag>
        <tag>vs code</tag>
        <tag>赛博朋克</tag>
        <tag>霓虹</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯方块试玩-react-tetris]]></title>
    <url>%2F2019%2F05%2F16%2F%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E8%AF%95%E7%8E%A9-react-tetris%2F</url>
    <content type="text"><![CDATA[试玩用手机浏览器打开https://chvin.github.io/react-tetris/ 真的好经典啊，小时候的游戏机就有，不过我玩这个真的很菜…很快就堵死了hhhhhhhhhhh Github地址https://github.com/chvin/react-tetris 开发者是用React、Redux、Immutable做俄罗斯方块游戏。响应式设计真的很方便，文档里还讲了开发过程时的细节，好棒！ 果断给了Star，然后把在线玩的地址作为书签放在手机桌面w]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>Immutable</tag>
        <tag>页面游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LogoDiy试玩-PB风格Logo制作]]></title>
    <url>%2F2019%2F05%2F16%2FLogoDiy%E8%AF%95%E7%8E%A9-PB%E9%A3%8E%E6%A0%BCLogo%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在线Logo制作工具https://www.logodiy.online/ 直接打开就可以制作了！我们熟悉的风格~立马制作了几个试试： Github地址http://t.cn/EKJMeRt 果断点了star! 美中不足的是，预设的Color Prefix和Suffix只有一种，要是起码有3种搭配好的预设颜色就更好了，希望以后会有]]></content>
      <tags>
        <tag>logo制作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下Chrome浏览器快捷键]]></title>
    <url>%2F2019%2F05%2F15%2Fwindows%E4%B8%8BChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[https://support.google.com/chrome/answer/157179?hl=zh-Hans 因为上面那个网址得科学上网才能打开，所以我在这里COPY下来，方便自己使用 Windows 和 Linux 标签页和窗口快捷键 操作 快捷键 打开新窗口 Ctrl + n 在无痕模式下打开新窗口 Ctrl + Shift + n 打开新的标签页，并跳转到该标签页 Ctrl + t 重新打开最后关闭的标签页，并跳转到该标签页 Ctrl + Shift + t 跳转到下一个打开的标签页 Ctrl + Tab 或 Ctrl + PgDn 跳转到上一个打开的标签页 Ctrl + Shift + Tab 或 Ctrl + PgUp 跳转到特定标签页 Ctrl + 1 到 Ctrl + 8 跳转到最后一个标签页 Ctrl + 9 在当前标签页中打开主页 Alt + Home 打开当前标签页浏览记录中记录的上一个页面 Alt + 向左箭头键 打开当前标签页浏览记录中记录的下一个页面 Alt + 向右箭头键 关闭当前标签页 Ctrl + w或Ctrl + F4 关闭当前窗口 Ctrl + Shift + w 最小化当前窗口 Alt + 空格键 + n 最大化当前窗口 Alt + 空格键 + x 关闭当前窗口 Alt + F4 退出 Google Chrome Ctrl + Shift + q Google Chrome 功能快捷键 操作 快捷键 打开 Chrome 菜单 Alt + f或Alt + e 或 F10 + Enter 键 显示或隐藏书签栏 Ctrl + Shift + b 打开书签管理器 Ctrl + Shift + o 在新标签页中打开“历史记录”页 Ctrl + h 在新标签页中打开“下载内容”页 Ctrl + j 打开 Chrome 任务管理器 Shift + Esc 将焦点放置在 Chrome 工具栏中的第一项上 Shift + Alt + t 将焦点放置在 Chrome 工具栏中的最后一项上 F10 将焦点移到未聚焦于的对话框（如果显示）中 F6 打开查找栏搜索当前网页 Ctrl + f 或 F3 跳转到与查找栏中搜索字词相匹配的下一条内容 Ctrl + g 跳转到与查找栏中搜索字词相匹配的上一条内容 Ctrl + Shift + g 打开“开发者工具” Ctrl + Shift + j 或 F12 打开“清除浏览数据”选项 Ctrl + Shift + Delete 在新标签页中打开 Chrome 帮助中心 F1 使用其他帐号登录或以访客身份浏览 Ctrl + Shift + m 打开反馈表单 Alt + Shift + i 地址栏快捷键 操作 快捷键 使用默认搜索引擎进行搜索 输入搜索字词并按Enter 键 使用其他搜索引擎进行搜索 输入搜索引擎名称，然后按Tab 键 为网站名称添加 www. 和 .com，并在当前标签页中打开该网站 输入网站名称并按 Ctrl + Enter 键 打开新的标签页并执行 Google 搜索 输入搜索字词并按 Alt + Enter 键 跳转到地址栏 Ctrl + l、Alt + d或F6 从页面中的任意位置搜索 Ctrl + k或Ctrl + e 从地址栏中移除联想查询内容 按向下箭头键以突出显示相应内容，然后按Shift + Delete 键 网页快捷键 操作 快捷键 打开选项以打印当前网页 Ctrl + p 打开选项以保存当前网页 Ctrl + s 重新加载当前网页 F5或Ctrl + r 重新加载当前网页（忽略缓存的内容） Shift + F5 或Ctrl + Shift + r 停止加载网页 Esc 浏览下一个可点击项 Tab 浏览上一个可点击项 Shift + Tab 使用 Chrome 打开计算机中的文件 按住 Ctrl + o 键并选择文件 显示当前网页的 HTML 源代码（不可修改） Ctrl + u 将当前网页保存为书签 Ctrl + d 将所有打开的标签页以书签的形式保存在新文件夹中 Ctrl + Shift + d 开启或关闭全屏模式 F11 放大网页上的所有内容 Ctrl 和 + 缩小网页上的所有内容 Ctrl 和 - 将网页上的所有内容恢复到默认大小 Ctrl + 0 向下滚动网页，一次一个屏幕 空格键 或 PgDn 向上滚动网页，一次一个屏幕 Shift + 空格键 或 PgUp 转到网页顶部 首页 转到网页底部 末尾 在网页上水平滚动 按住 Shift 键并滚动鼠标滚轮 将光标移到文本字段中的上一个字词前面 Ctrl + 向左箭头键 将光标移到文本字段中的上一个字词后面 Ctrl + 向右箭头键 删除文本字段中的上一个字词 Ctrl + Backspace 在当前标签页中打开主页 Alt + Home 鼠标快捷键 操作 快捷键 在当前标签页中打开链接（仅限鼠标） 将链接拖到标签页中 在新的后台标签页中打开链接 按住 Ctrl 键的同时点击链接 打开链接，并跳转到该链接 按住 Ctrl + Shift 键的同时点击链接 打开链接，并跳转到该链接（仅使用鼠标） 将链接拖到标签栏的空白区域 在新窗口中打开链接 按住 Shift 键的同时点击链接 在新窗口中打开标签页（仅使用鼠标） 将标签页拖出标签栏 将标签页移至当前窗口（仅限鼠标） 将标签页拖到现有窗口中 将标签页移回其原始位置 拖动标签页的同时按 Esc 将当前网页保存为书签 将相应网址拖动到书签栏中 下载链接目标 按住 Alt 键的同时点击链接 显示浏览记录 右键点击“后退”箭头 或“前进”箭头 ，或者点击（按住鼠标按键别松手）“后退”箭头 或“前进”箭头 在最大化模式和窗口模式间切换 双击标签栏的空白区域 放大网页上的所有内容 按住 Ctrl 键的同时向上滚动鼠标滚轮 缩小网页上的所有内容 按住 Ctrl 键的同时向下滚动鼠标滚轮]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>快捷键</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我喜欢用的win10快捷键]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%88%91%E5%96%9C%E6%AC%A2%E7%94%A8%E7%9A%84win10%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Alt + Tab 在打开的应用之间切换 F5刷新强迫症的我，特别喜欢刷新和清空回收站 WIN+PrtScn 截图就和steam里F12一样，全屏幕截图 WIN + Pause 显示“系统属性”对话框我只在这种时候才会用上Pause键… WIN + 加号 (+) 打开“放大镜”录教学类视频时才用的功能 Home键用电脑刷微博的时候，有时“返回顶部”button怎么找都找不到，这时用键盘右边上角的Home键就行了，一秒带你上天 虚拟桌面键盘快捷键WIN + Tab 打开任务视图我的大爱 WIN + Ctrl + D 添加虚拟桌面 WIN + Ctrl + F4 关闭你正在使用的虚拟桌面我一开始创建新的虚拟桌面时总是忘记如何关闭，越创越多… WIN + Ctrl + 向右键→ 在你于右侧创建的虚拟桌面之间切换WIN + Ctrl + 向左键← 在你于左侧创建的虚拟桌面之间切换无缝切换2333]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>win10</tag>
        <tag>WIN10</tag>
      </tags>
  </entry>
</search>
